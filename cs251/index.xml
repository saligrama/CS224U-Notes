<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS 251, Fall 2022 on Aditya's notes</title><link>https://saligrama.io/notes/cs251/</link><description>Recent content in CS 251, Fall 2022 on Aditya's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://saligrama.io/notes/cs251/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://saligrama.io/notes/cs251/2022-09-26-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-09-26-intro/</guid><description>CS 251 Blockchain and Cryptocurrency Technologies # This course # Brings together: cryptography, distributed systems, economics Course organization # The starting point: Bitcoin mechanics Consensus protocols Ethereum and decentralized applications DeFi: decentralized applications in finance Private transactions on a public blockchain: SNARKs and zero-knowledge proofs Scaling the blockchain: getting to 10K transactions/sec Interoperability among chains: bridges and wrapped coins What is a blockchain? # Consensus layer: public append-only data structure Persistence: can never remove added data Safety: all honest participants have same data Liveness: honest participants can add new transactions Open: anyone can add data (no authentication) Not strict requirement How are blocks added to chains?</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-09-28-bitcoin-mechanics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-09-28-bitcoin-mechanics/</guid><description>Bitcoin mechanics # Overview of the Bitcoin consensus layer # Miners broadcast received transaction (Tx) to peer-to-peer (P2P) network Every miner validates received Tx and stores them in its mempool (unconfirmed Tx set) Implication: miners see all Tx before posted on chain Every ~10 minutes: Each miner creates a candidate block from Tx in its mempool A &amp;ldquo;random&amp;rdquo; miner is selected and broadcasts its block to P2P network Selected miner is paid 6.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-03-bitcoin-scripts-and-wallets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-03-bitcoin-scripts-and-wallets/</guid><description>Bitcoin Scripts and Wallets # Managing secret keys # Users can have many PK/SK: per BTC/ETH/SOL/etc. addresses Wallets: Generate PK/SK and store SK Post and verify Tx Show balances Types of wallets: Cloud (e.g. Coinbase): like a bank, managed service Laptop/phone: electrum, metamask Hardware: Trezor, Ledger, Keystone, etc Paper: print all sk on paper Brain: memorize sk (bad idea) Hybrid: non-custodial cloud wallet (using threshold signatures) Need to safely manage keys: lose keys =&amp;gt; lose funds Hardware wallets # e.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-05-consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-05-consensus/</guid><description>Fundamentals of Consensus # Byzantine Generals Problem (Lamport et al., 1982) # N (fixed) generals, one is commander Some generals are loyal, some are traitors (incl. commander) Commander sends out order to attack or retreat Commander is loyal: send out same order to all generals Commander is traitor: sends out different orders to confuse Goal: all loyal generals should take the same action Which should be the one issued by the commander, if commander is loyal Generalized consensus problem # Solution to a consensus problem is a consensus protocol To generalize Byzantine Generals Probelm: generals are nodes, the commander is the leader, loyal generals are honest nodes, traitors are the adversary The adversary # Role of an adversary: corrupt nodes, making them adversarial Types of adversaries: Induces crash faults if the adversarial nodes do not send or receive any messages Induces omission faults if the adversarial nodes can selectively choose to drop or let through messages sent or received Note: omission fault adv.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-10-internet-consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-10-internet-consensus/</guid><description>Consensus on the internet # Characterized by open participation:
Adversary can create many Sybil nodes to try to take care of the protocol Honest participants come and go at will Goals:
Limit adversary&amp;rsquo;s participation - Sybil resistance Maintain availability (liveness) of protocol against fluctuating participation by honest nodes - dynamic availability Sybil-resistant protocols # How to select nodes to participate in consensus? Permissioned: fixed set of nodes (e.g., previous lecture) Permissionless: anyone satisfying certain criteria can participate However, we can&amp;rsquo;t accept anyone with a signing key: sybil attack Sybil attack: single node pretends to be multiple fake identities to gain network influence Example sybil-resistant protocols: Proof-of-work: computational power dedicated to protocol; e.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-17-ethereum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-17-ethereum/</guid><description>Ethereum # Limitations of Bitcoin # UTXO contains ScriptPK or hash thereof Simple script: indicates conditions when UTXO can be spent However: difficult to maintain state in multi-stage contracts or to enforce global rules on assets e.g. rate limiting: if wallet has 100 UTXOs, and want to enforce transfer of max 2BTC per day out of wallet, this is impossible! Example: NameCoin # DNS on the blockchain Need operations: Name.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-19-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-19-solidity/</guid><description>Solidity # Etherum contracts: write code in Solidity (most common) or other frontend languages Compiles to EVM bytecode Validators use EVM to execute contract bytecode in response to Tx An example contract: NameCoin contract nameCoin { struct nameEntry { address owner; bytes32 value; } mapping (bytes32 =&amp;gt; nameEntry) data; // insecure: front-running bug, can be solved using committments function nameNew(bytes32 name) { // registration cost is 100 Wei if (data[name] == 0 &amp;amp;&amp;amp; msg.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-11-02-legal-aspects-and-regulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-11-02-legal-aspects-and-regulation/</guid><description>Cryptocurrency Law and Regulation # Guest lecture by Jake Chervinsky, The Blockchain Association
Basics of regulations # Regulations: rules that either prohibit conduct or condition it on compliance with specific obligations; call for punishment of violators Purpose: control market power, facilitate competition, attract investment, protect consumers, achieve other government interests Regulation in the US # Creators and enforcers of regulation: Regulation on both state, federal level Legislature makes laws, executive enforces law, judiciary interprets laws Elected vs.</description></item></channel></rss>