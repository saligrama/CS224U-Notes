<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aditya's notes</title><link>https://saligrama.io/notes/</link><description>Recent content on Aditya's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://saligrama.io/notes/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://saligrama.io/notes/cs103/2020-09-16-set-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-09-16-set-theory/</guid><description> Set theory # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-09-18-indirect-proofs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-09-18-indirect-proofs/</guid><description> Indirect proofs # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-09-18-mathematical-proofs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-09-18-mathematical-proofs/</guid><description> Mathematical proofs # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-09-26-first-order-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-09-26-first-order-logic/</guid><description> First-order logic # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-09-26-propositional-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-09-26-propositional-logic/</guid><description> Propositional logic # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-09-27-first-order-logic-continued/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-09-27-first-order-logic-continued/</guid><description> First-order logic, continued # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-09-30-binary-relations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-09-30-binary-relations/</guid><description> Binary relations # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-01-binary-relations-continued/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-01-binary-relations-continued/</guid><description> Binary relations, continued # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-04-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-04-functions/</guid><description> Functions # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-10-cardinality/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-10-cardinality/</guid><description> Cardinality # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-11-graph-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-11-graph-theory/</guid><description> Graph theory # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-17-pigeonhole-principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-17-pigeonhole-principle/</guid><description> Pigeonhole principle # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-18-induction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-18-induction/</guid><description> Mathematical induction # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-19-induction-variants/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-19-induction-variants/</guid><description> Induction variants # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-20-computability-and-formal-languages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-20-computability-and-formal-languages/</guid><description> Computability and formal languages # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-25-nondeterministic-finite-automata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-25-nondeterministic-finite-automata/</guid><description> Nondeterministic finite automata # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-26-nfa-dfa-equivalence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-26-nfa-dfa-equivalence/</guid><description> NFA-DFA equivalence # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-10-26-regular-expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-10-26-regular-expressions/</guid><description> Regular expressions # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-11-01-nonregular-languages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-11-01-nonregular-languages/</guid><description> Nonregular languages # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-11-02-context-free-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-11-02-context-free-grammars/</guid><description> Context-free grammars # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-11-03-turing-machines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-11-03-turing-machines/</guid><description> Turing machines # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-11-08-turing-machine-subroutines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-11-08-turing-machine-subroutines/</guid><description> Turing machine subroutines # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-11-08-universal-turing-machine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-11-08-universal-turing-machine/</guid><description> Universal Turing machine # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-11-08-unsolvable-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-11-08-unsolvable-problems/</guid><description> Unsolvable problems # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs103/2020-11-14-unsolvable-problems-continued/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs103/2020-11-14-unsolvable-problems-continued/</guid><description> Unsolvable problems, continued # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-09-18-integer-representations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-09-18-integer-representations/</guid><description> Integer representations # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-09-21-bitwise-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-09-21-bitwise-operations/</guid><description> Bitwise operations # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-09-25-c-chars-and-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-09-25-c-chars-and-strings/</guid><description> C chars and strings # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-09-28-more-c-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-09-28-more-c-strings/</guid><description> More c strings # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-02-pointers-arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-02-pointers-arrays/</guid><description> Pointers arrays # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-05-stack-and-heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-05-stack-and-heap/</guid><description> Stack and heap # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-09-c-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-09-c-generics/</guid><description> C generics # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-12-function-pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-12-function-pointers/</guid><description> Function pointers # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-16-assembly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-16-assembly/</guid><description> Assembly # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-19-assembly-arithmetic-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-19-assembly-arithmetic-logic/</guid><description> Assembly arithmetic logic # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-23-assembly-control-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-23-assembly-control-flow/</guid><description> Assembly control flow # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-26-assembly-function-calls-and-return-stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-26-assembly-function-calls-and-return-stack/</guid><description> Assembly function calls and return stack # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-10-30-heap-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-10-30-heap-management/</guid><description> Heap management # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs107/2020-11-09-program-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs107/2020-11-09-program-optimization/</guid><description> Program optimization # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-03-30-course-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-03-30-course-overview/</guid><description>Course info # Course site: cs110l.stanford.edu
Topics # How to prevent common mistakes in systems programming?
Memory safety and common errors in C/C++ Preventing common memory safety errors in Rust Avoiding multiprocessing pitfalls Avoiding multithreading pitfalls Networked systems Grading # Course is pass/fail and the pass threshold is 70%
Components:
Lecture (2x 50min/week) Weekly exercises (40%) Small programming problems to reinforce week&amp;rsquo;s lecture material Alternatively: blog posts about course material Expected time: 1-3 hours per week Projects (40%) Mini GDB High-performance web server Participation (20%) Why Rust?</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-01-fixing-c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-01-fixing-c/</guid><description>C/C++ tools for code safety # Dynamic analysis # Valgrind # On-the fly instrumentation of binaries Works with all binaries compiled by all compilers, even without source code/debug symbols Drawback: Not much information in binaries; no information about stack allocation (so no detection of stack buffer overflows) LLVM sanitizers # Instrumentation of source code Provided by LLVM compiler suite (i.e., Clang) More information because source code is instrumented rather than binaries Examples:</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-06-intro-to-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-06-intro-to-rust/</guid><description>Why Rust (from a memory perspective) # What makes good code?
Pre/post conditions to break code into small pieces with well-defined interfaces in between Want to reason about small pieces in isolation If pre/post conditions of each piece is held up in isolation, then simply stringing them together works without having to keep entirety of program in one&amp;rsquo;s head Code with good memory management clearly defines how memory is passed around and &amp;ldquo;who&amp;rdquo; is responsible for cleaning it up C/C++&amp;rsquo;s compiler cannot effectively verify pre/post conditions with regards to memory.</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-08-ownership/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-08-ownership/</guid><description>Drop trait # drop function called at end of scope (designated by curly braces) Special function that properly frees an entire object (maybe multiple pointers to free) Similar to C++ destructor Classes that implement a drop function have a Drop trait fn main() { let a = &amp;#34;Hello, world!&amp;#34;.to_string(); let b = a; } // a, b dropped here: drop only called on b Copy trait # Some values in Rust don&amp;rsquo;t use the heap and are stored directly on the stack (integer types, booleans, etc) These are copied by default when assigning variables, so drop doesn&amp;rsquo;t need to be called Types with this property have the Copy trait If a type has the Copy trait, it cannot also have the Drop trait Variable rules # All pieces of data in Rust are by default immutable (i.</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-13-error-handling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-13-error-handling/</guid><description>Error handling # Error handling in C # If a function can encounter an error, its return type is int or void * If successful, it returns 0, otherwise, returns -1 (or valid pointer/NULL) Function that encountered error sets global variable errno to be an integer indicating what went wrong (many such codes). If -1 or NULL was returned, caller should check errno. Heavy burden on programmer to remember how each specific function works Handling specific errors using errno creates mess of if statements Error handling using exceptions (most languages including C++) # Error happens: error propagates up the stack until handled by try/catch or reaches main and crashes program Errors will not go unnoticed, unlike C: avoids undefined behavior Disadvantages: Overhead in terms of code size Failure modes become hard to reason about; any function can throw any exception at any time Error handling in Rust # Enum (enumeration) # Type that can contain one of several variants enum TrafficLightColor { Red, Yellow, Green, } let current_state : TrafficLightColor = TrafficLightColor::Green; Match expression: like a switch statement, but all possible variants must be covered.</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-22-traits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-22-traits/</guid><description>Traits # Create functions that we want classes to duplicate (or redefine), but outside a super class Code gets injected into any existing structure (both custom types and standard ones) Trait methods do not need to be fully defined, can define stub methods/declarations Data is not inherited Advantages:
Code reuse: Can create trait with parametrized functions implemented differently for different traits Code hiding: All parts of a trait are exposed, but we can specify exactly which functions should be injected, so no accidental spillover Example:</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-27-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-27-generics/</guid><description>Generics # Allow us to factor out types and write less code No performance impact at runtime: compiler creates separate functions for types that are used Example:
fn foo&amp;lt;T&amp;gt;(x : T, y : T) -&amp;gt; T { // do something } fn main() { let x, y : usize = // some vals foo(x, y); let a, b : f32 = // some vals foo(a, b); } We can put constraints on the input types:</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-29-multiprocessing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-29-multiprocessing/</guid><description>C: fork() # Why it&amp;rsquo;s problematic:
Accidentally nesting forks when spawning multiple children Children can execute code they weren&amp;rsquo;t supposed to Accessing data structures during threading Zombie children if waitpid() isn&amp;rsquo;t called C: execvp() # Execute code we want to run concurrently in a separate executable, using arguments or pipes for args Simple and powerful: can make any changes to environment before executing a program, but this isn&amp;rsquo;t easy Common multiprocessing paradigm to replace fork and execvp # fork() and exec() still exist Define higher-level abstraction for common cases ex.</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-03-31-threads-and-dispatching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-03-31-threads-and-dispatching/</guid><description>Threads # Definition: a thread is a sequential execution stream (i.e., executes instructions sequentially, one after another)
Virtualization # Concept: one thing can behave like another - indistinguishably so
Why? Because modern computer hardware deals with threads in a complex, parallel (rather than serial) way, but we can treat threads as single units without having to worry about complex hardware interactions
Execution state # Definition: Everything that can affect a thread, or be affected by it</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-02-concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-02-concurrency/</guid><description>Concurrency # Independent threads # Definition: a thread that can&amp;rsquo;t effect or be affected by any other thread (execution state isn&amp;rsquo;t shared with other threads)
Properties:
Deterministic: input state exactly determines results Reproducible Scheduling order irrelevant Example: arithmetic operations
In practice: this almost never happens; thread states are almost always shared within the OS
Cooperating threads # Definition: Cooperating threads have a shared state
Properties:
Nondeterministic Not necessarily reproducible Example: suppose these are running on different threads</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-05-synchronization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-05-synchronization/</guid><description>Synchronization # Definition: Using atomic operations to ensure correct operation of cooperating threads (includes both safety and liveness properties)
Critical section: Piece of code where only one thread can execute at once
Mutual Exclusion (mutex): Mechanisms for implementing critical sections
Computerized milk purchase # if (milk == 0) { if (note == 0) { note = 1 buy_milk(); note = 0; } } This doesn&amp;rsquo;t work, because thread 1 can see a zero value for note while thread 0 is setting note to 1.</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-07-shared-memory-and-condition-variables-and-locks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-07-shared-memory-and-condition-variables-and-locks/</guid><description>Shared memory # Which variables are shared? # Programmer decides All memory potentially shareable (in process) Stack locals: private Globals: shared Pointers stored in globals: shared Pointers passed as arguments when instantiating threads: shared void my_func(int x) { int y; // private Pool p; // private } Pool p2; // public Thread safety # Refers to a class designed for shared use std::vector is not thread-safe For thread-unsafe classes: must manually lock externally Condition variables # std::condition_variable</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-09-lock-implementation-and-deadlocking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-09-lock-implementation-and-deadlocking/</guid><description>Implementing locks # For multiple cores:
Atomic operations: read-modify-write Swap: Reads word Writes new value Returns old value Version 1: Spin Lock # class Lock { Lock() {} std::atomic&amp;lt;int&amp;gt; locked(0); } void Lock::lock() { while (locked.swap(1)) { // do nothing // continue looping until we get a 0 back (old value) } } void Lock::unlock() { locked = 0; } Version 2: less busy waiting # class Lock { Lock() {} std::atomic&amp;lt;int&amp;gt; locked(0); ThreadQueue q; } void Lock::lock() { if (locked.</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-12-scheduling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-12-scheduling/</guid><description>Single-core scheduling # Computational resources # Preemptible: Can give to a thread and can take it away Network interfaces Scheduling: how long thread keeps resources, who&amp;rsquo;s next Non-preemptible: Can&amp;rsquo;t take away without permission File space Allocation: who gets what Deciding which resources are preemptible or not is associated with the cost to preempt.
Which thread should run on which core for how long?
Goals # Minimize response time (to useful result - down to human response time of 50-100ms) Use resources efficiently Keep resources busy if there is work to do for them Minimize context switches First-come-first-serve (FCFS/FIFO) # Keep a ready queue of runnable threads When a thread becomes runnable, add it to the back When a core runs out of work to do (locks or exits), run first thread on queue Disadvantage: One thread can monopolize core</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-14-multiprocessing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-14-multiprocessing/</guid><description>Multiprocessor scheduling # Simple approach # Shared ready queue, lock One dispatcher per core Timer interrupts per core Core takes highest-priority thread and runs it When a thread becomes runnable:
If the new thread is higher priority, preempt existing thread Contention for lock and queues # Have a separate ready queue per core Balance load across cores (work stealing) Work conservation # If there is a ready thread currently queued, and there&amp;rsquo;s an idle core, thread will run on that core Core affinity # Expensive to move a thread to a new core Try to keep the thread on the same core Gang scheduling # Run threads of a process together (on different cores) Otherwise, what happens is: One thread locks Deschedule Other threads may block on lock Keep thread loaded even if blocked?</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-16-linking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-16-linking/</guid><description>Linking # Memory # Process memory layout:
Process creation # Linkers # Unix: ld Windows: LINK.exe What does it do?
Combine object files (compiled from source) Computes memory layout Fix memory addresses Produces executable Problems it has to deal with:
Assembler doesn&amp;rsquo;t know where code or data will go in memory Makes a guess: Assume sections will be located at 0, write everything as such Assembler doesn&amp;rsquo;t know addresses of external objects Makes a guess: Assume 0 and leave a note for the linker Object file # Contains:</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-19-storage-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-19-storage-management/</guid><description>Dynamic storage management # Problem: unpredictability
Operations: # alloc(nbytes) -&amp;gt; ptr free(ptr) Stack allocation # Freeing is predictable: just LIFO order! Heap Allocation # Freeing is unpredictable Memory has allocated areas and free areas (&amp;ldquo;holes&amp;rdquo;) Fragmentation: Small holes, can&amp;rsquo;t effectively use for allocation
Goal: Minimize fragmentation
Free lists # Data structure that keeps track of holes
Best fit # Linked list of free blocks On allocation, scan entire list and pick the smallest block that can fit requested size On free, try to merge a block with its neighbors First fit: # Stop at first block that is large enough</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-21-virtual-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-21-virtual-memory/</guid><description>Virtual memory # How to share one set of memory between multiple processes?
Goals:
Multitasking: memory shared between processes running at the same time Transparency: user processes should not have awareness of shared memory Process should see only its own private pool of memory Isolation: one process can&amp;rsquo;t corrupt another Efficiency: don&amp;rsquo;t want to add extra runtime to OS code or complexity to use code Load-time relocation # When loading process,</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-23-dynamic-address-translation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-23-dynamic-address-translation/</guid><description>Dynamic Address Translation # Goal: Make a process think it has its own memory space independent from all other processes
Process&amp;rsquo;s memory would start at 0 Hardware has
CPU core Memory management unit Converts virtual addresses (process memory space) to physical addresses (actual hardware memory address) Memory Base and Bound # Virtual address space goes from 0 to Bound Physical address for same process goes from Base to Base+Bound Properties:</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-26-segmentation-and-paging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-26-segmentation-and-paging/</guid><description>Virtual memory schemes # Segmentation # Process has multiple segments of memory (code, data, stack)
MMU has a segment map with one entry per segment, with three fields:
Base Bound Writeable bit (is process allowed to modify the segment) Segment number can be from:
Top bits of virtual address Implicit from instruction Instructions vs data x86 prefixes Advantages:
Manage segments separately Move/swap to disk Share code segments between processes Have same base/bound numbers Disadvantages:</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-04-30-demand-paging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-04-30-demand-paging/</guid><description>Demand paging # Program can run without loading everything into memory Keep active info in memory Inactive info on disk in paging file/backing store/swap space Locality: Most of the time, a process uses only a small fraction of its code and data
Disk: 100x cheaper than DRAM DRAM: 100,000x faster than disk Each page in VAS either
in memory (physical page frame) on disk in backing store Page fault procedure # Reference to page not in memory Present bit 0 Trap to OS Find tree page Read data from backing store Set present bit to 1 Resume execution Technicalities:</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-05-disks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-05-disks/</guid><description>Disks # 6-12 platters, each with 200k inch tracks, 1000 sectors per track, 4096 bytes per sector Total capacity ~100GB to 18TB I/O operation # Seek: position heads over track we want to read or write (2-10ms) Rotational latency: 4ms at 7500RPM Transfer: 100-150 MB/sec API: # void read(start_sector, sector_count, phys_mem_addr); void write(start_sector, sector_count, phys_mem_addr); Disk structure hidden because
Inner tracks have fewer sectors Disk can remap bad sectors Device registers # One block per device Words in physical memory Parameters Status bits (&amp;ldquo;completed&amp;rdquo;, &amp;ldquo;error&amp;rdquo;) Control bits set by CPU (&amp;ldquo;start operation&amp;rdquo;) Don&amp;rsquo;t behave like memory Some fields might always read as 0 Can change without being written to Operation # Write register to start Ready bit reads as 0 When operation does, ready bit reads as 1 Interrupts # &amp;ldquo;Interrupt enabled&amp;rdquo; (IE) bit in register After starting operation, OS will set this bit OS does something else When device becomes ready, checks IE bit If IE bit on, device interrupts when ready Save IP and PS Branch into OS, load new PS (stored in interrupt vector) Disable IE in handler Multi-core machines: spread interrupts to many cores</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-07-file-systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-07-file-systems/</guid><description>File systems # Issues:
Disk space management File naming/lookup Reliability, file recovery Protection: isolating and sharing user data File # Definition: Named collection of bytes stored durably
Access patterns:
Sequential Random access: access by position Notes:
Most files are small: need to keep file metadata very small Large files occupy most of the disk Most IO for large files Files can grow Inode # Definition: OS info about a file</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-10-realworld-filesystem-structures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-10-realworld-filesystem-structures/</guid><description>DOS/Windows FAT # Linked list: links in File Allocation Table One entry per block Next block in file &amp;ldquo;Last block&amp;rdquo; &amp;ldquo;Free block&amp;rdquo; Inode: first block in file Free list: like a bit map Originally: 16-bit entries, 512 byte blocks =&amp;gt; 32 Mb disks Advantages:
Random access is fairly fast Sequential access is easy FAT itself is free list! No pointers in data block Contiguous allocation is possible Disadvantages:
Fragmentation issues (but better than linked files) FAT32 # 28-bit sector numbers Clusters: groups of sectors, 2-32kb 4kb clusters: 1TB disks Multi-level indexes (4.</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-12-directories/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-12-directories/</guid><description>Inode allocation # Where on disk for inodes? Contiguous array at outer edge: lots of seeks Many arrays, spaced over disk FS tries to allocate data for an inode near the inode itself Index in array: i-number, unique identifier for a file Directories # Map from name to i-number Previously: one directory per disk, then per user Today: hierarchical directories Stored like regular files inode has special bit indicating it&amp;rsquo;s a directory Root directory has i-number 2 Procedure for looking up file # File: /a/b/c</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-14-crash-recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-14-crash-recovery/</guid><description>Crash recovery # Crashes can happen anywhere Lost data Inconsistency Modification affects several blocks Add block to file: modify 2 blocks (bitmap, inode) &amp;ldquo;Atomic ops&amp;rdquo;: all or nothing for multi-block ops? fsck # Fix on reboot Checks to see if system shutdown cleanly Set flag on disk during normal shutdown If hard shutdown, flag won&amp;rsquo;t be set - then run fsck Reboot: clear flag If not, scan disk, find and fix inconsistencies Goals:</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-19-protection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-19-protection/</guid><description>Protection # Prevent accidental/intentional misuse Authentication: identify principal Authorization: who may do what Entacement Authentication # Passwords: secret info
Need to be long and secure Need lots of them! Phishing/social engineering works Must protect database: never store pwd in clear One-way transforms: given ciphertext, can&amp;rsquo;t compute clear text; different cleartext yields different ciphertext Key/badge
No need for secrecy If stolen, will know Requires physical presence to steal 2-factor authentication</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-24-flash-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-24-flash-memory/</guid><description>Flash memory # Flash vs disk:
No moving parts More shock resistant 100x lower latency 5-10x higher cost per bit Flash vs DRAM:
Nonvolatile 5-10x lower cost per bit 1000x higher latency Hardware:
Individual chips can be up to 512GB Erase units: 256kb Pages: 512 or 4096 bytes Reads: pages Writes: Erase: sets all bits in an erase unit to 1 Writes: pages: logical AND with data written and data existing (0s never change back to 1) Wear-out: limit on how many erases can be invoked without degrading reliability (1k-100k) Performance:</description></item><item><title/><link>https://saligrama.io/notes/cs111/2021-05-28-virtual-machines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs111/2021-05-28-virtual-machines/</guid><description>Virtual machines # &amp;ldquo;process&amp;rdquo; running in its own computer Can have many VMs on a single machine hypervisor: implements VM abstraction guest OS: runs in VM Hypervisors # Simulator, use file to hold virtual disk and software emulation of CPU/memory oprations Examples: Bochs, Emu 100x slower for computation 2x slower for I/O Use machine to simulate itself? Guest OS in user mode Most instructions execute natively Trap and simulate &amp;ldquo;unusual&amp;rdquo; instructions Simulating an OS # Privileged instructions (i.</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-03-29-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-03-29-intro/</guid><description>Compilers # Course structure # Course has theoretical and practical aspects Need both in programming languages! Written assignments and exams cover theory Programming assignments cover the practical/systems part Course goal # Open lid of compilers and see inside Understand what they do, how they work, how to build them Correctness over performance Will not cover lots of optimizations - will need CS243 for it Course project # Write own compiler in four parts: PA1: lexer PA2: parser PA3: type checker PA4: code generation How are languages implemented?</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-03-31-language-design-and-cool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-03-31-language-design-and-cool/</guid><description>Language design # Languages are adopted to fill a void Enable a previously difficult/impossible application Can be orthogonal to language quality Programmer training is the dominant cost Languages with many users are rarely replaced Popular languages become ossified But easy to start in a new niche Why so many languages? # Application domains have distinctive and conflicting needs Rust: systems programming w/focus on security R: statistics w/focus on streams Python: scripting Julia: linear algebra Javascript: able to run in browser No universally accepted metrics for design Abstraction # Detatched from concrete details Information hiding: expose only the essential Modes of abstraction Via languages/compilers: higher level code, few machine dependencies Via functions/subroutines: abstract interface to behavior Via modules: export interfaces, hide implementation Via classes or abstract data types: bundle data with operations Types # Originally, few types FORTRAN: scalars, arrays LISP: no static type distinctions Realization: types help Allows expressing abstraction Lets compiler report many frequent errors Allows guaranteeing certain types of &amp;ldquo;safety&amp;rdquo; Reuse # Exploit common patterns in software systems Goal: mass-produced software components Two popular approaches Type parametrization: std::vector&amp;lt;int&amp;gt;, std::vector&amp;lt;double&amp;gt; Classes and inheritance: C++ derived classes C++ and Java have both Inheritance allows Specialization of existing abstractions Extension, modification, hidden behavior Trends # Language design Many new special-purpose languages Popular languages stick around (perhaps forever) Fortran and Cobol Compilers Ever more needed and more complex Driven by increasing gap between new languages and architectures Venerable and healthy area COOL overview # COOL: Classroom Object Oriented Language</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-04-05-lexical-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-04-05-lexical-analysis/</guid><description>Lexical analysis # Goal: partition input strings into substrings; i.e.
if (i == j) z = 0; else z = 1; converts to
&amp;#34;if(i==j)\n\tz=0;\n\telse\n\tz=1&amp;#34; which we want to select the relevant tokens from.
Tokens # Tokens are a syntactic category
In English: noun, verb, adjective, etc. In programming languages: identifier, integer, keyword, whitespace, etc. A token class corresponds to a set of strings; e.g.
Identifier: strings of letters or digits, starting with a letter Integer: a non-empty string of digits Keyword: if, else, begin, etc.</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-04-07-lexical-analysis-implementation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-04-07-lexical-analysis-implementation/</guid><description>Implementation of Lexical Analysis # Stages of code processing in lexical analysis:
Lexical Specification Regular Expressions NFA DFA Table-driven implementation of DFA Converting a lexical specification to a regular expression # Notation # Union: A + B = A | B Option: A + ε = A? Range: &amp;lsquo;a&amp;rsquo; + &amp;lsquo;b&amp;rsquo; + &amp;hellip; + &amp;lsquo;z&amp;rsquo; = [a-z] Excluded range: complement of [a-z] = ^[a-z] Steps # Write a regex for each token Number = digit + Keyword = 'if' + 'else' + .</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-04-12-parsing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-04-12-parsing/</guid><description>Parsing # Parser functionality # Input: sequence of tokens from lexer Output: parse tree of the program (in practice, Abstract Syntax Tree) Parser distinguishes between valid and invalid strings of tokens Requires a language for describing valid strings of tokens Requires a method for distinguishing between valid and invalid strings of tokens e.g.
COOL syntax: if x = y then 1 else 2 fi Parser input (Lexer output): IF ID = ID THEN INT ELSE INT FI Parser output: Context-Free Grammars # Disadvantages of regular languages:</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-04-14-syntax-directed-translation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-04-14-syntax-directed-translation/</guid><description>Error handling # Purpose of the compiler is to detect non-valid programs and to translate the valid ones Many kinds of possible errors: Lexical (detected by lexer) Syntax (detected by parser) Semantic (detected by type checker) Correctness (detected by tester/user) Syntax error handling # Error handler should Report errors accurately and clearly Recover from an error quickly Not slow down compilation of valid code Good error handling is not easy to achieve Panic Mode # Simplest, most popular method of error detection When an error is detected: Discard tokens until one with a clear role is found Continue from there These tokens are called synchronizing tokens Usually statement or expression terminators e.</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-04-19-top-down-parsing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-04-19-top-down-parsing/</guid><description> Top-down parsing # Predictive parsers # Like recursive-descent, but parser can &amp;ldquo;predict&amp;rdquo; which production to use by looking at next few tokens (no backtracking) Predictive parsers accept LL(k) grammars First L: &amp;ldquo;left-to-right&amp;rdquo; input scan Second L: &amp;ldquo;leftmost derivation&amp;rdquo; k: &amp;ldquo;predict based on k tokens of lookahead&amp;rdquo; In practice: LL(1) LL(1) vs Recursive Descent # Recursive Descent: at each step, many choices of production to use Backtracking used to undo bad choices LL(1): at each step, only one choice of production When non-terminal A is leftmost in a derivation and next input t, either: Unique production A -&amp;gt; α to use No production to use (error state) Like a recursive descent variant but without backtracking Predictive parsing and left factoring # Example: consider grammar E -&amp;gt; T + E | T T -&amp;gt; int | int * T | ( E ) This is hard to predict because For T two productions start with int For E unclear how to predict Requires left-factoring the grammar Factor out common prefixes of productions: E -&amp;gt; T X X -&amp;gt; + E | ε T -&amp;gt; int Y | ( E ) Y -&amp;gt; * T | ε</description></item><item><title/><link>https://saligrama.io/notes/cs143/2022-04-26-semantic-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs143/2022-04-26-semantic-analysis/</guid><description>Semantic Analysis # Purpose of semantic analysis # Why separate semantic analysis?
Parsing cannot catch some errors Some language constructs are not context-free What does semantic analysis do? Checks constructs depending on language
coolc checks:
All identifiers are declared Types Inheritance relationships Classes defined only once Class methods only defined once Reserved identifiers are not misused etc. Types of semantic analysis checks # Scope # Matching identifier declarations with uses Important static analysis step in most languages, including COOL The scope of an identifier is the portion of a program in which that identifier is accessible Same identifier may refer to different things in different parts of the program An identifier may have restricted scope Static scope: depends only on program text, not run-time behavior (most languages, including COOL) Uses of an identifier refer to closest enclosing definition in program text Dynamic scope: depends on program execution (LISP, SNOBOL) Uses of an identifier refer to closest encloding binding in program execution In COOL: Not all kinds of identifiers follow most-closely-nested rule e.</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-09-27-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-09-27-intro/</guid><description>Parallel Computing # Course themes # Designing parallel programs that scale # Parallel thinking Decomposing work into pieces that can safely be performed in parallel Assigning work to processors Managing communication/synchronization between the processors to not limit speedup Parallel computer hardware implementation # How do parallel computers work? Mechanisms used to implement different abstractions efficiently Performance characteristics of implementations Design tradeoffs: performance vs. convenience vs. cost Why know about hardware?</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-09-29-modern-multicore-processors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-09-29-modern-multicore-processors/</guid><description>A Modern Multi-core Processor # Part 1: Speeding up an example sine program # Computes sin across an array of float values using a Taylor series expansion
void sinx(int N, int terms, float *x, float *y) { for (int i = 0; i &amp;lt; N; i++) { float value = x[i]; float numer = x[i] * x[i] * x[i]; int denom = 6; // 3! int sign = -1; for (int j = 1; j &amp;lt;= terms; j++) { value += sign * numer / denom; numer *= x[i] * x[i]; denom *= (2 * j + 2) * (2 * j + 3); sign *= -1; } y[i] = value; } } This compiles to some assembly:</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-04-parallel-abstractions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-04-parallel-abstractions/</guid><description>Parallel Abstractions and Implementation # ISPC # Intel SPMD (single program, multiple dat) Program Compiler: https://ispc.github.io e.g. sinx using ISPC
export void ispc_sinx( // uniform: type modifier for optimization, not necessary for correctness uniform int N, uniform int terms, uniform float *x, uniform float *result ) { // programCount: keyword, number of simultaneously executing gang instances for (uniform int i = 0; i &amp;lt; N; i += programCount) { // programIndex: id of current gang instance int idx = i + programIndex; float value = x[idx]; float numer = x[idx] * x[idx] * x[idx]; uniform int denom = 6; uniform int sign = -1; for (uniform int j = 1; j &amp;lt;= terms; j++) { value += sign * numer / denom; numer *= x[idx] * x[idx]; denom *= (2*j+2) * (2*j + 3); sign *= -1; } result[idx] = value; } } int main (int argc, char **argv) { // initializations ispc_sinx(N, terms, x, result); return 0; } ISPC execution Call to ISPC function spawns &amp;ldquo;gang&amp;rdquo; of ISPC &amp;ldquo;program instances&amp;rdquo; All instances run ISPC code concurrently Each instance has its own copy of local variables Upon return, all instances have completed What ISPC does Turns instructions into SIMD at compilation time Number of instances in a gang: SIMD width of the hardware (or small multiple thereof) Does not spawn new threads!</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-06-parallel-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-06-parallel-models/</guid><description>Models of Parallel Programming # Three types of models:
Shared address space: very little structure to communication Message passing: communication is structured in the form of messages Communication explicit in source code Data parallel structure: more rigid structure to computation Same function on collection of large elements Shared address space model # All threads access the same memory Requires coordinated access to shared data using locks, e.g. // thread 1 int x = 0; Lock my_lock; spawn_thread(foo, &amp;amp;x, &amp;amp;my_lock); my_lock.</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-11-work-distribution-and-scheduling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-11-work-distribution-and-scheduling/</guid><description>Performance Optimization: Work Distribution and Scheduling # Programming for high performance # Iterative process: refine choices for decomposition, assignment, orchestration Goals (that can be at odds with each other): Balance workload onto available execution resources Reduce communication Reduce extra work overhead Note: always implement the simplest solution first, then profile to figure out where and how to do better for best impact Balancing the workload # Static assignment # Assignment of work to threads not dependent on runtime factors Note: distribution not determined at compile-time; can be impacted by provided parameters Good properties of static assignment: Simple, near-zero runtime overhead for assignment (e.</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-13-locality-communication-and-contention/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-13-locality-communication-and-contention/</guid><description>Performance Optimization: Locality, Communication, Contention # Message passing review # Machine model: cluster of two machines, each with own processor/memory/cache, and communication via network (costly) Note: communication can also be between cores on a chip, core and its cache, core and memory This model allows us to think of a parallel system as extended memory hierarchy, in terms of increasing latency: Processor Registers Local L1 cache Local L2 cache L2 from another core L3 cache Local memory Remote memory (one network hop) Remote memory (N network hops) Communication: via send/receive messages send: specifies recipient, buffer to be transmitted, identifier (tag) receive: sender, specifies buffer to store data, identifier (tag) Only way for thread communication Synchronous (blocking) send/receive # send(): call returns once sender receives acknowledgement that message data resides in address space of receiver recv(): call returns when data from received message copied into receiver address space and acknowledgement sent back to sender Non-blocking asynchronous send/receive # send(): call returns immediately Buffer provided to send cannot be modified by calling thread since message processing occurs concurrently with thread execution Calling thread can perform other work while waiting for send recv(): posts intent to receive in the future, returns immediately Use checksend(), checkrecv() to determine actual status of send/receipt Calling thread can perform other work while waiting for receive Communicaton-to-computation ratio # Fraction: (# bytes communication)/(# instructions computation) If denominator is execution time of computation, then ratio gives avg.</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-18-gpu-architecture-and-cuda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-18-gpu-architecture-and-cuda/</guid><description>GPU architecture and CUDA # GPU history # Graphical purpose of a GPU # Initially designed for: Input: description of a scene; mathematical description e.g. 3D surface geometry, surface materials, lights, camera, etc. Output: image of the scene Rendering task # Real-time graphics primitives (entities) Surfaces represented as 3D triangle meshes: vertices (points in space), primitives (points, lines, triangles) Goal: compute how each triangle in 3D mesh contributes to overall image Subtask workload: given triangle, determine where it lies on screen given position of virtual cameras For all output image pixels covered by triangle, compute color of surface at that pixel Shader program: run once per fragment (per pixel covered by triangle) Inputs: variable values that change per pixel Outputs: colors at those pixels Pixels covered by multiple surfaces contain output from surfaces closest to camera To optimize: GPUs designed with multiple core, high-throughput (lots of SIMD and multithreading) architecture GPUs for scientific and compute task # Initial observation (2001-2003): GPUs are very fast processors for performing same computation in parallel on large collections of data Data parallelism!</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-20-data-parallel-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-20-data-parallel-architecture/</guid><description>Data-parallel thinking # Motivation # Idea: express algorithms in terms of operations on sequences of data e.g. map, filter, fold/reduce, scan/segmented scan, sort, groupby, join, partition/flatten High-performance parallel versions exist; so can we reframe programs in these terms to make them run efficiently on a parallel machine? In general: applications need to expose a large amount of data parallelism to make use of High core counts Multiple machines SIMD processing GPU architectures Key terms and operations # Data-parallel model, sequences, map: recall Lecture 4&amp;rsquo;s intro on data parallelism Fold (fold left) # Apply binary operation f to each element and an accumulated value; seeded by initial value of type b f :: (b, a) -&amp;gt; b fold :: b -&amp;gt; # initial element ((b, a) -&amp;gt; b) -&amp;gt; # function to fold seq a -&amp;gt; # input sequence b # output e.</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-25-spark/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-25-spark/</guid><description>Spark: Distributed Computing on a Cluster # Cluster environment # Main idea: distributed computing, programming with 10k-100k cares How to ensure no data loss in case of failure of some system component? Programming model: data-parallel operations (e.g. Map and Reduce) Goal: make data-parallel operations Scalable (100ks of cores) Fault-tolerant (ensure no data loss in case of failure) Efficient (optimize system perf. with efficient use of memory) Why use a cluster?</description></item><item><title/><link>https://saligrama.io/notes/cs149/2022-10-27-cache-coherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs149/2022-10-27-cache-coherence/</guid><description>Cache coherence # Brief background on caches # Recall: die size of CPU is significantly occupied by cache! L3: per chip, one bank per core L2, L1: private per core Lower levels: faster/closer access for a core Associativity: flexibility of where a cache can put a memory address 4C&amp;rsquo;s cache miss model: Cold: first access, never seen before Capacity: cache is finite size, data evicted Conflict: when cache is not fully associative Coherence Review: cache design # Example: suppose code executes int x = 1; where x corresponds to address 0x12345604 in memory Cache line: data is 64 bytes on modern Intel processors e.</description></item><item><title/><link>https://saligrama.io/notes/cs154/2021-09-28-finite-automata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs154/2021-09-28-finite-automata/</guid><description> Finite automata # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs154/2021-10-05-pumping-lemma-and-myhill-nerode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs154/2021-10-05-pumping-lemma-and-myhill-nerode/</guid><description> Pumping Lemma and Myhill-Nerode Theorem # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs154/2021-10-12-streaming-algorithms-and-turing-machines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs154/2021-10-12-streaming-algorithms-and-turing-machines/</guid><description> Streaming algorithms and Turing machines # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-03-28-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-03-28-intro/</guid><description>Computer and Network Security: Overview # The computer security problem # Lots of buggy software Money can be made from finding and exploiting vulns Marketplace for exploits (gaining a foothold) Marketplace for malware (post-compromise) Strong economic and political motivation for using both Current state: Existence of vulns is somewhat evenly distributed across OS&amp;rsquo;s Usage of exploits: almost 50% start by attacking Microsoft Office; 32% start by attacking the browser Course goals # Understand exploit techniques Learn to defend and prevent common exploits Understand available security tools Learn to architect secure systems This course # Part 1: basics (architecting for security) Securing apps, OS, and legacy code: sandboxing, access control, and security testing Part 2: Web security (defending against a web attacker) Building robust websites, understanding the browser security model Part 3: network security (defending against a network attacker) Monitoring and architecting secure networks Part 4: securing mobile applications Course introduction: what motivates attackers?</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-03-30-control-hijacking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-03-30-control-hijacking/</guid><description>Basic Control Hijacking Attacks # Attacker&amp;rsquo;s goal: Take over target machine (e.g., web server) Execute arbitrary code on target by hijacking application control flow Examples: Buffer overflow and integer overflow attacks Format string vulnerabilities Use after free Buffer overflow attacks # Extremely common in C/C++ programs Now advised to avoid C/C++ Use Rust: typesystem should help avoid these bugs First major exploit: 1988 internet worm, bug in fingerd What is needed:</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-04-control-hijacking-defenses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-04-control-hijacking-defenses/</guid><description>Control Hijacking Defenses # Note: control hijacking attacks occur because data is mixed with control flow in memory -&amp;gt; allows attackers to mess with control flow by manipulating data
Ways to prevent control hijacking attacks:
Fix bugs Audit software: automated tools include Coverity, Infer, etc. Rewrite software in a type-safe language (Java, Go, Rust) - however this is difficult for existing/legacy code Platform defenses: prevent attack code execution Harden executable to detect control hijacking Halt processes and report when exploit detected e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-06-security-principles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-06-security-principles/</guid><description>Principles of secure systems # Inevitability of vulnerabilities # Very easy to make mistakes involving buffer overflow, use-after-free, or null pointer dereferences Many such mistakes can allow attackers to run malicious code As such, there will always be bugs, even as we get better at finding and preventing them Systems must be designed to be resilient in the face of both software vulnerabilities and malicious users Defense in Depth # Systems should be built with security protections at multiple layers e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-11-isolation-and-sandboxing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-11-isolation-and-sandboxing/</guid><description>Isolation and Sandboxing # Goal: run untrusted code without compromising systems
Programs from untrusted Internet sites Mobile apps, JS, browser extensions Exposed applications: Browser, PDF viewer, email client Legacy daemons: sendmail, bind Honeypots If application misbehaves, want to kill it Approach: confinement # Idea: ensure misbehaving app cannot harm rest of system Can be implemented at many levels Hardware: run application on isolated hardware (airgap) - difficult to manage Virtual machines: isolate OS&amp;rsquo;s on a single machine Process level: system call interposition; isolate a process in a single OS Threads: software fault isolation (SFI) Isolating threads sharing same address space Application level confinement e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-13-vuln-finding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-13-vuln-finding/</guid><description>Finding vulnerabilities using fuzzing, dynamic, and static analysis # Conceptualizing vulnerabilities # Computer programs can be thought of as finite state machines The code we want to write represents states we intend to reach However, code can also have unintended states if miswritten Bugs exist when there are reachable states in the runnable state machine (the code) that have no corresponding state in the intended state machine (the design) Vulnerabilities live in this unintended space; exploitation is making the program do &amp;ldquo;interesting&amp;rdquo; transitions in the unintended state space Types of bugs: Design issue: the conceptual state machine does not meet intended goals e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-18-web-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-18-web-security/</guid><description>Web Security Model # Web security goals # Safely browse the web: Sites should not be able to steal data from device, install malware, access camera, etc Sites should not be able to affect or eavesdrop on other sessions Support secure high-performance web apps Web-based applications should have same or better security properties as desktop applications Attack models # Malicious website Malicious external resources Network attacker Malware attacker HTTP protocol # ASCII protocol from 1989 that allows fetching resources (e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-20-web-attacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-20-web-attacks/</guid><description>Web Attacks # Cookie Attack # Suppose CS155 allows you to login and submit homework at cs155.stanford.edu Login with username and password; cs155.stanford.edu responds with cookies: session=abc Now access dabo.stanford.edu/memes, dabo.stanford.edu sets cookie to cookies: session=def for Domain=stanford.edu Now browser will send both session cookies, and it is up to server to determine which is correct Cross-Site Request Forgery # Type of web exploit where a website transmits unauthorized commands as a user that the web app trusts In CSRF attack, user is tricked into submitting an unintended/unrealized request to website Cookie-based authentication is not sufficient for requests that have any side effect Preventing CSRF attacks: Referer validation Secret validation token Custom HTTP header sameSite cookies Referer validation # Referer header contains address of previous web page from which a link to currently requested page was followed Allows servers to identify where people are visiting from https://bank.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-25-web-defenses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-25-web-defenses/</guid><description>Authentication and Session Management # Pre-history: HTTP auth # HTTP request: GET /index.html HTTP response contains: WWW-Authenticate: Basic realm=&amp;quot;Password Required&amp;quot; Browser sends hashed password on all subsequent HTTP requests Caveats: User cannot log out other than by closing browser What if user has multiple accounts? Site cannot customize password dialog Confusing dialog to users Easily spoofed Modern session management # Login # When visiting website, site creates anonymous session and hands session ID back in a cookie User will POST with username and password, website checks credentials and elevates token to logged-in Logout # Delete session token from client Mark session token as expired on server Authenticating users # First idea: plaintext passwords (terrible) Store password and check match against user input Don&amp;rsquo;t trust anything that provides you your password Second idea: store password hash (bad) Store SHA-1(pw) and check match against SHA-1(input) Weak against attacker who has hashed common passwords Third idea: store salted hash (better) Store (r, SHA-1(pw + r)) and check against SHA-1(input + r) Prevents attackers from precomputing password hashes Need to make sure to choose a hash function that is expensive to compute In practice: use bcrypt, scrypt, or pbkdf2 when building an application Phishing attacks # Attacker sends a fraudulent message that tricks user into revealing sensitive data (e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-05-04-processor-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-05-04-processor-security/</guid><description>Processor security # The processor # Part of the trusted computing base (TCB) But is optimized for performance Security may be secondary Processor design and security: Important security features Hardware enclaves Memory encryption (TME) RDRAND etc. Some features can be exploited for attacks Speculative execution Transactional memory Intel Software Guard eXstensions (SGX) # Extension to Intel processors that support Enclaves: running code and memory isolated from rest of system Attestation: prove to local/remote system what code is running in enclave Minimum TCB: only processor is trusted and nothing else DRAM and peripherals are untrusted Writes to memory are encrypted Applications Storing a web server HTTPS secret key: secret key only opened inside an enclave Malware cannot get the key Note: this is different from TPM2 - TPM2 only provides secure storage at boot, after that it&amp;rsquo;s all in memory Running a private job in the cloud: job runs in enclave Cloud admin cannot get code or data or job Client side: hide antivirus signatures AV signatures are only opened inside an enclave Data science on federated data Compute on shared data, without ever having to share the data with anyone else SGX now deprecated in consumer CPUs, only available in server CPUs SGX enclaves # Application defines part of itself as an enclave Untrusted part of memory creates enclave Enclave is isolated memory in process memory space Inaccessible while processor is not in SGX mode Untrusted part can call a trusted function in the enclave To do execution, processor goes into SGX mode Creating en enclave: ECREATE: establish mem addr for enclave EADD: copy memory pages into enclave EEXTEND: compute hash of enclave contents, 256 bytes at a time EINIT: verifies that hashed content is properly signed; if so, initializes enclave (signature: RSA3072) EENTER: call function inside enclave EEXIT: return from enclave SGX attestation # Problem: enclave memory is in the clear prior to activation (EINIT) How to get secrets into enclave?</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-05-09-internet-protocol-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-05-09-internet-protocol-security/</guid><description>Internet Protocol Security # The Internet # Global protocol that provides best-effort delivery of packet between connected hosts Packet: structured sequence of bytes Header: metadata used by network Payload: user data to be transported Every host has a unique identifier - IP address Series of routers receive packets, look at header destination address, and send it one hop towards destination IP address Network protocols # Define how hosts communicate in published network protocols Syntax: how communication is structured (e.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-03-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-03-intro/</guid><description>CS 161 Design and Analysis of Algorithms # About the course # Course goals # The design and analysis of algorithms These go hand in hand In this course Learn to think analytically about algorithms Flesh out an &amp;ldquo;algorithmic toolkit&amp;rdquo; Learn to communicate clearly about algorithms Guiding questions # Does it work? Is it fast? Can I do better? Should it work? Should it be fast? Logistics # Lectures</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-05-worst-case-and-asymptotic-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-05-worst-case-and-asymptotic-analysis/</guid><description>Worst-case and asymptotic analysis # Worst-case analysis # An algorithm must be correct on all possible inputs The running time of the algorithm is the worst possible running time over all inputs That is, if we design a purposefully adversarial input, the algorithm should still work on that input Pro and con: very strong guarantee Asymptotic analysis: Big-O notation # Meaningful way to talk about the runtime of an algorithm, independent of programming language or computing platform, without having to count all of the operations Focuses on how the runtime scales with input size n Highest-degree term in the sum is the only one that counts e.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-10-recurrence-relations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-10-recurrence-relations/</guid><description> Recurrence relations # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-12-median-and-selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-12-median-and-selection/</guid><description>The k-SELECT problem # Let A be an array of integers and let k be an integer Goal: Return the k&amp;rsquo;th smallest element of A e.g. A = [7, 4, 3, 8, 1, 5, 9, 14] SELECT(A, 1) = 1 SELECT(A, 2) = 3 SELECT(A, 3) = 4 SELECT(A, 8) = 14 SELECT(A, 1) = MIN(A) SELECT(A, n/2) = MEDIAN(A) O(n log n) algorithm # Very simple! Sort the array, return A[k-1] What we want: an O(n) algorithm # Ex.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-19-randomized-algorithms-and-quicksort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-19-randomized-algorithms-and-quicksort/</guid><description>Randomized Algorithms # Idea: make random choices during the algorithm
Hope the algorithm works Hope the algorithm is fast Today: look at algorithms that always work and are probably fast
e.g. select with random pivot Analysis of randomized algorithms # Scenario 1: publish algorithm, adversarially picked input, run algorithm (expected running time - as a random variable)
Scenario 2: publish algorithm, adversarially picked input and randomness (worst-case analysis)
Bogosort # Algorithm BogoSort(A):</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-24-sorting-lower-bounds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-24-sorting-lower-bounds/</guid><description>Sorting lower bounds # Defining a valid sorting algorithm # Comparison-based model of computation (requires Ω(n log n) steps):
Input: array Output: sorted array Operations allowed: comparisons Another model:
CountingSort and RadixSort Run in time O(n) Ω(n log n) bound for comparison sorting # Theorem:
Any deterministic comparison-based sorting algorithm must take Ω(n log n) steps Any randomized comparison-based sorting algorithm must take Ω(n log n) steps in expectation Argument:</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-26-binary-search-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-26-binary-search-trees/</guid><description> Binary search trees # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-31-hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-31-hashing/</guid><description>Hashing # Generic data structure that allows fast insert/delete/search Doesn&amp;rsquo;t need items to be comparable, only hashable Idea: get better performance in expectation using randomness Primitive: direct addressing # Suppose all keys are in the set {1..9} Create buckets 1..9 Insert: map key i to bucket i Delete: remove from bucket i Search: look for bucket i Problem: if keys are arbitrary, this requires a lot of memory
An improvement: put items in buckets based on one digit</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-02-graphs-and-graph-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-02-graphs-and-graph-search/</guid><description> Graphs and graph search (BFS and DFS) # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-07-strongly-connected-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-07-strongly-connected-components/</guid><description> Strongly connected components # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-09-weighted-graphs-and-dijkstra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-09-weighted-graphs-and-dijkstra/</guid><description> Weighted graphs and Dijkstra&amp;rsquo;s algorithm # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-14-dynamic-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-14-dynamic-programming/</guid><description>Dynamic Programming # Definitions # Dynamic programming: algorithmic design paradigm Usually for solving optimization problems (i.e., shortest path) Also useful for combinatorial problems (i.e., how many ways are there to achieve some task?) Elements of dynamic programming # Optimal sub-structure (necessary for DP to be correct) Big problems break up into subproblems e.g. Fibonacci (below): F(i) for i &amp;lt;= n e.g. Bellman-Ford (below): shortest paths with at most i edges for i &amp;lt;= n The solution to a problem can be expressed in terms of solutions to smaller subproblems e.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-16-dynamic-programming-applications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-16-dynamic-programming-applications/</guid><description>Applications of Dynamic Programming # Longest Common Subsequence # Definition # Subsequence: chosen sequential subset of a sequence e.g.: BDFH is a subsequence of ABCDEFGH If X, Y are sequences, a common sequence that is a subsequence of both e.g. BDFH is a subsequence of ABCDEFGH and of ABDFGHI Longest common subsequence (LCS) is a common subsequence that is the longest e.g. ABDFGH is the LCS of of ABCDEFGH and of ABDFGHI Dynamic programming steps # Optimal substructure Subproblems will be finding LCS&amp;rsquo;s of prefixes to X and Y Let C[i, j] = length_of_LCS(X[i], Y[j]) Case 1: X[i] = Y[j] Then C[i, j] = 1 + C[i-1,j-1] (because we can continue the previous subsequences by adding the new common character) Case 2: X[i] !</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-23-greedy-algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-23-greedy-algorithms/</guid><description>Greedy Algorithms # Idea:
Make choices one-at-a-time Never look back Hope for the best However: does not work everywhere.
When to use greedy algorithms? # Problem should exhibit optimal substructure:
Optimal solutions to a problem are made up from optimal solutions of subproblems Each problem depends on only one subproblem Common strategy for proving correctness # Make a series of choices Suppose we&amp;rsquo;re on track to make optimal solution T* Show that at each step, choices won&amp;rsquo;t rule out a globally optimal solution Suppose that T* disagrees with the next greedy choice Manipulate T* in order to make a solution T that&amp;rsquo;s not worse but agrees with the next greedy choice Swap choice k instead of choice j After having made all choices, we haven&amp;rsquo;t ruled out an optimal solution, so the solution we found is optimal This can be turned into an inductive proof.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-28-minimum-spanning-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-28-minimum-spanning-trees/</guid><description> Minimum spanning trees # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs224u/2021-03-29-course-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs224u/2021-03-29-course-overview/</guid><description>Why Natural Language Understanding? # Perfect moment because the field is at or near peak Recent resurgence of interest Heavy industry use Still many weaknesses in existing systems Far from solved - still remain big breakthroughs to be found Course info # Course site: https://cs224u.stanford.edu
Code repo: https://github.com/cgpotts/cs224u
Topics # Vector-space models Sentiment analysis Contextual word representations Grounded language generation Relation extraction Natural Language Inference NLU and info. retrieval Adversarial testing Methods and metrics Assignments # Word relatedness Cross-domain sentiment analysis Generating color descriptions in context Each assignment culminates in a bakeoff - informal competition in which original models are entered</description></item><item><title/><link>https://saligrama.io/notes/cs224u/2021-03-31-vector-space-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs224u/2021-03-31-vector-space-models/</guid><description>Distributed word representations # Meaning representations # Co-occurrence matrix:
Meaning can be present in such a matrix.
If a word co-occurs often with &amp;ldquo;excellent,&amp;rdquo; it likely is a positive word; if it co-occurs often with &amp;ldquo;terrible,&amp;rdquo; it likely denotes something negative Guiding hypothesis for vector-space models # The meaning of a word is derived from its use in a language. If two words have similar vectors in a co-occurrence matrix, they tend to have similar meanings (Turney and Pantel, 2010).</description></item><item><title/><link>https://saligrama.io/notes/cs224u/2021-04-12-sentiment-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs224u/2021-04-12-sentiment-analysis/</guid><description>Supervised sentiment analysis # Tokenization # Whitespace tokenizer # Very simple, just splits sentences into words by spacing. Example:
&amp;gt; whitespace_tokenizer(&amp;#34;The quick fox jumped over the lazy dog.&amp;#34;) [&amp;#39;The&amp;#39;, &amp;#39;quick&amp;#39;, &amp;#39;fox&amp;#39;, &amp;#39;jumped&amp;#39;, &amp;#39;over&amp;#39;, &amp;#39;the&amp;#39;, &amp;#39;lazy&amp;#39;, &amp;#39;dog.&amp;#39;] Note: simplest version will not take punctuation into account, which could be disruptive for using with VSMs
Sentiment-aware tokenizer # Ideally, a tokenizer would
Isolate emoticons Respects domain-specific markup (i.e., hashtags and @-mentions) Uses underlying markup Capture masked curses such as f@#$%ing Preserve meaningful capitalization Regularizes lengthening (i.</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-09-21-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-09-21-intro/</guid><description> Intro # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-09-23-supervised-learning-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-09-23-supervised-learning-setup/</guid><description> Supervised learning setup # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-09-28-logistic-regression/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-09-28-logistic-regression/</guid><description> Logistic regression # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-09-30-generalized-linear-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-09-30-generalized-linear-models/</guid><description> Generalized linear models # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-10-05-generative-learning-algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-10-05-generative-learning-algorithms/</guid><description> Generative learning algorithms # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-10-07-naive-bayes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-10-07-naive-bayes/</guid><description> Naive bayes # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-10-12-kernel-methods-and-svm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-10-12-kernel-methods-and-svm/</guid><description> Kernel methods and SVM # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-10-14-deep-learning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-10-14-deep-learning/</guid><description> Deep learning # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-10-19-deep-learning-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-10-19-deep-learning-optimization/</guid><description> Deep learning optimization # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs229/2021-10-21-model-selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs229/2021-10-21-model-selection/</guid><description> Model selection # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-09-26-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-09-26-intro/</guid><description>CS 251 Blockchain and Cryptocurrency Technologies # This course # Brings together: cryptography, distributed systems, economics Course organization # The starting point: Bitcoin mechanics Consensus protocols Ethereum and decentralized applications DeFi: decentralized applications in finance Private transactions on a public blockchain: SNARKs and zero-knowledge proofs Scaling the blockchain: getting to 10K transactions/sec Interoperability among chains: bridges and wrapped coins What is a blockchain? # Consensus layer: public append-only data structure Persistence: can never remove added data Safety: all honest participants have same data Liveness: honest participants can add new transactions Open: anyone can add data (no authentication) Not strict requirement How are blocks added to chains?</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-09-28-bitcoin-mechanics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-09-28-bitcoin-mechanics/</guid><description>Bitcoin mechanics # Overview of the Bitcoin consensus layer # Miners broadcast received transaction (Tx) to peer-to-peer (P2P) network Every miner validates received Tx and stores them in its mempool (unconfirmed Tx set) Implication: miners see all Tx before posted on chain Every ~10 minutes: Each miner creates a candidate block from Tx in its mempool A &amp;ldquo;random&amp;rdquo; miner is selected and broadcasts its block to P2P network Selected miner is paid 6.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-03-bitcoin-scripts-and-wallets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-03-bitcoin-scripts-and-wallets/</guid><description>Bitcoin Scripts and Wallets # Managing secret keys # Users can have many PK/SK: per BTC/ETH/SOL/etc. addresses Wallets: Generate PK/SK and store SK Post and verify Tx Show balances Types of wallets: Cloud (e.g. Coinbase): like a bank, managed service Laptop/phone: electrum, metamask Hardware: Trezor, Ledger, Keystone, etc Paper: print all sk on paper Brain: memorize sk (bad idea) Hybrid: non-custodial cloud wallet (using threshold signatures) Need to safely manage keys: lose keys =&amp;gt; lose funds Hardware wallets # e.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-05-consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-05-consensus/</guid><description>Fundamentals of Consensus # Byzantine Generals Problem (Lamport et al., 1982) # N (fixed) generals, one is commander Some generals are loyal, some are traitors (incl. commander) Commander sends out order to attack or retreat Commander is loyal: send out same order to all generals Commander is traitor: sends out different orders to confuse Goal: all loyal generals should take the same action Which should be the one issued by the commander, if commander is loyal Generalized consensus problem # Solution to a consensus problem is a consensus protocol To generalize Byzantine Generals Probelm: generals are nodes, the commander is the leader, loyal generals are honest nodes, traitors are the adversary The adversary # Role of an adversary: corrupt nodes, making them adversarial Types of adversaries: Induces crash faults if the adversarial nodes do not send or receive any messages Induces omission faults if the adversarial nodes can selectively choose to drop or let through messages sent or received Note: omission fault adv.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-10-internet-consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-10-internet-consensus/</guid><description>Consensus on the internet # Characterized by open participation:
Adversary can create many Sybil nodes to try to take care of the protocol Honest participants come and go at will Goals:
Limit adversary&amp;rsquo;s participation - Sybil resistance Maintain availability (liveness) of protocol against fluctuating participation by honest nodes - dynamic availability Sybil-resistant protocols # How to select nodes to participate in consensus? Permissioned: fixed set of nodes (e.g., previous lecture) Permissionless: anyone satisfying certain criteria can participate However, we can&amp;rsquo;t accept anyone with a signing key: sybil attack Sybil attack: single node pretends to be multiple fake identities to gain network influence Example sybil-resistant protocols: Proof-of-work: computational power dedicated to protocol; e.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-17-ethereum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-17-ethereum/</guid><description>Ethereum # Limitations of Bitcoin # UTXO contains ScriptPK or hash thereof Simple script: indicates conditions when UTXO can be spent However: difficult to maintain state in multi-stage contracts or to enforce global rules on assets e.g. rate limiting: if wallet has 100 UTXOs, and want to enforce transfer of max 2BTC per day out of wallet, this is impossible! Example: NameCoin # DNS on the blockchain Need operations: Name.</description></item><item><title/><link>https://saligrama.io/notes/cs251/2022-10-19-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs251/2022-10-19-solidity/</guid><description>Solidity # Etherum contracts: write code in Solidity (most common) or other frontend languages Compiles to EVM bytecode Validators use EVM to execute contract bytecode in response to Tx An example contract: NameCoin contract nameCoin { struct nameEntry { address owner; bytes32 value; } mapping (bytes32 =&amp;gt; nameEntry) data; // insecure: front-running bug, can be solved using committments function nameNew(bytes32 name) { // registration cost is 100 Wei if (data[name] == 0 &amp;amp;&amp;amp; msg.</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-03-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-03-intro/</guid><description> Intro # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-05-stream-ciphers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-05-stream-ciphers/</guid><description> Stream ciphers # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-10-block-ciphers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-10-block-ciphers/</guid><description> Block ciphers # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-12-pseudorandom-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-12-pseudorandom-functions/</guid><description> Pseudorandom functions # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-19-data-integrity-and-macs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-19-data-integrity-and-macs/</guid><description> Data integrity and MACs # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-24-collision-resistance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-24-collision-resistance/</guid><description> Collision resistance # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-26-authenticated-encryption/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-26-authenticated-encryption/</guid><description> Authenticated encryption # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-01-31-key-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-01-31-key-management/</guid><description> Key management # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-02-02-key-exchange-math/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-02-02-key-exchange-math/</guid><description> Key exchange math # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-02-07-public-key-encryption/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-02-07-public-key-encryption/</guid><description> Public key encryption # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-02-09-pke-schemes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-02-09-pke-schemes/</guid><description> Pke schemes # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-02-14-digital-signatures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-02-14-digital-signatures/</guid><description> Digital signatures # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-02-16-certificates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-02-16-certificates/</guid><description> Certificates # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-02-23-id-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-02-23-id-protocols/</guid><description> Id protocols # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-02-28-key-exchange-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-02-28-key-exchange-protocols/</guid><description> Key exchange protocols # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-03-02-zero-knowledge-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-03-02-zero-knowledge-protocols/</guid><description> Zero knowledge protocols # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs255/2022-03-07-quantum-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs255/2022-03-07-quantum-cryptography/</guid><description> Quantum cryptography # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-09-20-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-09-20-intro/</guid><description>Class structure # Timing # Monday 11:30am-1:00pm: Tech lecture by Alex Wednesday 11:30am-1:30pm: Law lecture by Riana Friday 1:30pm-2:30pm: Lab section by Austin Grading # 25% - weekly legal short response (due 11:59pm Tuesday) 25% - weekly lab assignments (due 11:00am Monday) 50% - exams May be curves upward for reasonable distribution
Exams # Take-home exam: take between Oct 20 and Oct 24 4hr to complete what should be a 2hr exam Technical and legal topics Multiple-choice, short-ansewr, practical challenges from labs Open note and open reading Final exam - in person at time TBA Technical and legal topics - biased towards post-midterm topics Multiple-choice, short-ansewr, practical challenges from labs Open note and open reading Offensive security # &amp;ldquo;Hacking&amp;rdquo;: Manipulating a system of hardware and software to do something unintended by the designer or owner of that system Motivations for hacking: Revolutions like Arab Spring, to overthrow authoritarian governments Authoritarian governments formed after Arab Spring, for societal control Nation-states, to destabilize and compete with other countries Individuals and organizations, either for financial (i.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-09-22-legal-intro-and-electronic-communications-privacy-act/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-09-22-legal-intro-and-electronic-communications-privacy-act/</guid><description>Legal intro # Course assignments: Short responses # Assigned Wednesday lecture; due 11:59pm following Tuesday Max 400 words Discussion with other students allowed but need to submit alone Grading: &amp;ldquo;needs improvement,&amp;rdquo; &amp;ldquo;meets expectations,&amp;rdquo; &amp;ldquo;exceeds expectation&amp;rdquo; Cyber issue forces at play # Pathetic Dot theory: Market, Law, Norms, Architecture
Industry standards, compliance bodies, self-regulatory schemes
ISO27001 - infosec management standards; can become legal req by law or contract PCI DSS - anti CC fraud Digital Advertising Alliance - ad industry self-reg body Tech companies enforcing standards + policing behavior</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-09-27-web-requests-and-attacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-09-27-web-requests-and-attacks/</guid><description>Web requests # GET requests # Useful for simple requests: retrieving a resource for a server; example: search
GET&amp;rsquo;s are idempotent: same request is the same every time; should not change server state GET fields are limited to the URI Single Sign On # Allows user to log into multiple websites with only one login system
Advantages:
Single security implementation; only one login account needs to be maintained Single point of failure Allows security team at SSO provider to shut down suspicious login requests on other sites Can force 2FA on multiple sites if SSO provider enforces it POST requests # For changing server state; contains URI but also can have much more fields that are not contained in the URI</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-09-29-ecpa-for-private-actors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-09-29-ecpa-for-private-actors/</guid><description>ECPA Continued # ECPA liability for private actors # Does WiFi &amp;ldquo;sniffing&amp;rdquo; violate the Wiretap Act? Statute: Not unlawful to intercept an electronic communication when readily accessible to general public This is to prevent penalizing radio hobbyists for listening in on radio frequencies Court: No! In re Innovatio IP Ventures, LLC Patent Litig., 886 F. Supp. 2d 888 (N.D. III 2012) Innovatio, a patent troll, used a &amp;ldquo;packet capture adapter&amp;rdquo; intercepted packets sent over WiFi to fish for IP violations on public WiFi networks Capture included content, not just metadata Court ruled this is not unlawful since it falls inside private interception exception Opinion held that sniffing public unencrypted WiFi comms is easy and cheap, so these comms are &amp;ldquo;readily accessible to the general public&amp;rdquo; Court: Maybe!</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-10-04-cyberattacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-10-04-cyberattacks/</guid><description>Anatomy of a Cyberattack # Classifying cyber actors # What can they do? (skill) Who are they? (attribution) Why? (goals) Money Political motivations Anarchy Leads to the question of: How can we deter them?
Types of state cyber actors # Superpowers: Five Eyes (US, UK, AU, CA, NZ); CH (Mandiant APT 1, APT 17); RU (Mandiant APT 28, APT 29); IL; FR, DE, NL (?) Large, well-funded professional organizations Full-spectrum operations including HUMINT Advanced, self-driving malware with 0-days Careful operational security (ability to not get caught) Rapid Risers: IR, KP, VE, SK Rapidly improving via investment and foreign help Often using cyber to level playing field Might have 0-day, often new malware Learn quickly from the superpowers The Peleton (IN, PK, SA, BR, TR) Cyber capabilities seen as part of national power Skilled, but perhaps smaller, teams Often dependent on private groups, superpowres Poised to break out with right investment Ambitious buyers (MX, ET, AE) Purchasing both software and often operations Limited in-house development Likely to use cyber power domestically Nation-state control # Most control: US, UK Offensive operations under direct control with legal guidelines Non-authorized hacking prosecuted More control: IN, SK Pro-government operations carriedout by independent group with tight controls Mixture: CH, TR, IL Mixture of first and third-party operations Independent groups allowed to operate but tightly controlled Less control: RU, VE Mixture of first and third-party operations Independent groups encouraged to go rogue, internal politics can be dangerous Lawless: NG, RO Hackers operate for pure profit motive, government cannot/will not intervene Cyber Kill Chain # Reconnaissance: Planning phase of operation; research on targets Weaponization: Preparation and staging phase of operation; automated generation of malware; weaponizer couples malware and exploit into a deliverable payload Delivery: Adversaries convey malware to the target Exploitation: Adversaries must exploit vulnerability to gain access (0-days) Installation: Adversaries install persistent backdoor in victim environment to maintain extended access Command and Control (C2): Malware opens a command channel to enable adversary to remotely manipulate the victim With hands-on keyboard access, intruders accomplish the mission&amp;rsquo;s goal Social engineering is much simpler: can accomplish goals (information theft) with only first 4 steps; phishing payload is easy to create.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-10-06-computer-fraud-and-abuse-act/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-10-06-computer-fraud-and-abuse-act/</guid><description>Computer Fraud and Abuse Act (CFAA) # TW: Suicide
Key concepts # &amp;ldquo;Access without authorization&amp;rdquo; Not defined in the statute &amp;ldquo;Exceeding authorized access&amp;rdquo; Defined in the statute yet courts still are inconsistent about interpretting it Recently interpreted by the Supreme Court in Van Buren v. United States Subsections: # a - Seven or more prohibitions (a)(1) Espionage prohibitions (a)(2) Obtaining information from 3 sources: financial/banking/credit institutions, federal govt, or &amp;ldquo;any protected computer&amp;rdquo; (a)(3) Trespass on federal government system (a)(4) Intent to defraud (a)(5) Causes damage (A) knowingly causes transmission of program that intentionally causes damage without authorization to a protected computer (B) intentionally accesses a protected compute rwithout authorization, and as a result of such conduct, recklessly causes damage (C) intentionally accesses a protected computer without authorization, and as a result of such conduct, causes damage and loss (a)(6) Password trafficking (a)(7) Extortion threats to a computer/data Renewed relevance in the age of ransomware b - Attempt and conspiracy c - Sentences for criminal violations d - Secret service power to investigate e - Definitions &amp;ldquo;damage&amp;rdquo;: any impairment to the integrity or availability of a data, a program, a system, or information &amp;ldquo;loss&amp;rdquo;: any reasonable cost to any victim: includes cost of incident response, damage assessment, data/program/system/information restoration, revenue lost, cost incurred, other consequential damages incurred because of interruption of service &amp;ldquo;protected computer*: (e)(2)(A) Financial or federal government computer (e)(2)(B) &amp;ldquo;used in or affecting interstate or foreign commerce or communication&amp;rdquo; -&amp;gt; any internet-connected computer (e)(2)(C), added 2020: &amp;ldquo;is part of a voting system&amp;rdquo;, either is used for federal election management/support/administration or &amp;ldquo;has moved in or otherwise affects interstate or foreign commerce&amp;rdquo; f - Law enforcementand intelligence agencies exception g - Civil cause of action, negligence exemption h - Reporting to Congress (now expired) i - Forfeiture provisions j - Forfeiture provisions Criminal cases under CFAA # Morris Worm (1988) # One of the first computer worms spread via Internet At least $100,000 in damage ($225,000 in 2021 dollars) Infected ~3-10% of all Internet-connect computers at the time First felony conviction under CFAA (upheld by Second Circuit, 1991) Convicted under then-current version of 1030(a)(5) which was subsequently amended in 1996 Indictments of state-sponsored hackers and look-alikes # China: Dec.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-10-11-network-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-10-11-network-security/</guid><description>Network Security # How does the internet work? # Packet Switching Break up internet communications messages into packages, release them onto the network, each node in the network forwards it to the next node until reaching the host which reassembles it into the correct order Two universally used protocols: IP - Internet Protocol BGP - Border Gateway Protocol Internal networks can be different (Comcast uses DOCSYS, AT&amp;amp;T uses LTE and 5G) but the networks themselves talk IP/BGP to each other Web layers # Notes:</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-10-13-cfaa-dmca-and-security-research/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-10-13-cfaa-dmca-and-security-research/</guid><description>Computer Fraud and Abuse Act (CFAA), continued # hiQ v. LinkedIn (oral arguments Oct. 18, 2021 - remanded to 9th circuit)
hiQ argument: Van Buren&amp;rsquo;s gates up/down inquiry means scraping publicly avail data is OK (gate up) but scraping private data (like in Power Ventures) is not (gate down) C&amp;amp;D letters and counter-bot measures don&amp;rsquo;t count as &amp;ldquo;down gates&amp;rdquo; since info is public LinkedIn argues: Public data counts as &amp;ldquo;authorization&amp;rdquo;, but LinkedIn put the &amp;ldquo;gate down&amp;rdquo; with C&amp;amp;D letter, targeted IP blocks, so after that hiQ access was without aughorization IP blocks are technological or code-based rstrictions on access, per Van Buren footnote 8 Southwest Airlines v.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-10-20-data-security-laws/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-10-20-data-security-laws/</guid><description>Data Security and Data Breach Notification Laws # Nothing comprehensive at the federal level; states have all the power here.
State Data Breach Notification Laws # Each state, plus DC/PR/VI/GU have one Laws share many commonalities, but plenty of variation Discovering/being notified of a &amp;ldquo;breach of the security of the system&amp;rdquo; triggers duty to notify Any state resident whose &amp;ldquo;personal information&amp;rdquo; (PI) was, or is reasonably believed to have been, acquired by an unauthorized person Definitions comonly used by many states: Breach of security of system: unlawful, unauthorized acquisition of PI PI: first name/initial + last name + 1 more of SSN, DL/ID card number, account/credit/debit number + pin/code/password Laws generally apply to computerized data that includes PI Excludes publicly available information lawfully made available to the public by government or media Many states add more types of info to definitions of PI Ex: in California</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-10-25-corporate-intrusion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-10-25-corporate-intrusion/</guid><description>Corporate Intrusion # Privilege escalation # An attacker starts with no privilege and no ability to access anything Initial entry point: sending a fake PDF to a lawyer, sending a fake Excel spreadsheet to an accountant, etc Attackers want to end with privileges necessary for their objectives Escalation may happen remotely or locally Computer privilege levels # Limited accounts (jails) - programs run with limited privileges to trap any attackers who successfully compromise them Normal user account - ability to run programs and access data in home and shared directories; but cannot install software and access data from other users Administrator/root - highest privileged user account, can access anything on the device but cannot necessarily modify OS itself Service accounts - used by software that runs in the background, has lots of power but cannot modify running system System/kernel - fully privileged to interact directly with hardware, access all data, modify running system Managed systems # Computers on a corporate network are managed by a central authority (i.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-10-27-ransomware-and-foreign-hackers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-10-27-ransomware-and-foreign-hackers/</guid><description>Ransomware and Foreign Hackers # TW: discussion of death of a baby
The recent ransomware boom # Why is ransomware so big now? Cryptocurrency.
Ransoms have been around for a long time, so has malware Historically, ransomware was used to hit small businesses and charge hundreds of dollars to recover data However, hackers now routinely extort critical infrastructure providers (gas pipelines, transportation systems, etc) for hundreds of millions of dollars Cryptocurrency is easier to obtain, transact, convert to real currency Exchanges are less uptight than backs about KYC (Know Your Customer)/AML (Anti Money Laundering) laws People generally think cryptocurrency is untraceable However: this myth was busted in June 2021 after FBI recovered 63.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-11-01-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-11-01-cryptography/</guid><description>Cryptography # Definitions # Cryptography: the study of secret or secure communications Cryptology: the study of math behind cryptography Cryptanalysis: code-breaking Plaintext: an unencrypted input/output of a cryptosystem Cryptotext: the encrypted output of a cryptosystem Goals of cryptosystems:
Confidentiality: keeping information private or secret Integrity: ensuring that information has not been modified Authentication: proving somebody is who they say they are Non-repudiation: proving that a message was sent by a specific actor Modern cryptography definitions # Key primitives # Key exchange: allows you to agree on a secret number Symmetric cipher: encrypts data using a shared key Block cipher: input fixed message size (for DES, 64 bits) Stream cipher: encrypts data one bit at a time Asymmetric cipher: encrypts/decrypts data with different keys Diffie-Hellman (DH): generate shared key from individual public/private keys Rivest-Shamir-Adleman (RSA): encrypt message using public key/private key Hash algorithm: generates a fingerprint for data Function that creates a &amp;ldquo;fingerprint&amp;rdquo; of an arbitrary input that is deterministic, fixed length, and very difficult to reverse Digital signature: proves that data was sent by holder of private key Building blocks of modern cryptography # Digital signatures: proof of identity of users/server Key exchange protocol: share secret key between users/user and server Symmetric cipher: use the secret key to encrypt/decrypt messages Hashes and signatures: make sure the message hasn&amp;rsquo;t been tampered with Uses of encryption # Transport encryption: create a secure tunnel (e.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-11-03-cyber-conflict/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-11-03-cyber-conflict/</guid><description>Cyber conflict # Nation-state-level hacking # Motivations # Financial gain (IP theft, economic development) Information collection (espionage) Covert action (information operations, sabotage) Armed conflict (if there is one already, or to start one) &amp;ldquo;Prepare the battlefield&amp;rdquo; - gain access to targeted system now to take action on it later &amp;ldquo;Hold at risk&amp;rdquo; - deterrence measures; let other side know you can damage their asset Retaliation options # Ignore it Make threatening noises, but don&amp;rsquo;t do anything (i.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-11-08-dark-web-and-cryptocurrencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-11-08-dark-web-and-cryptocurrencies/</guid><description>The Dark Web # Internet routing # The ideal: anarchism; &amp;ldquo;The Net interprets censorship as damage and routes around it&amp;rdquo; In reality: a few centralized providers maintain infrastructure for all internet communications A LOT of traffic flows through the US NSA saw this as an opportunity for surveillance Also: China&amp;rsquo;s censorship is extremely effective! Can do blocking on traffic that leaves Chinese servers A solution has been to use VPNs, though blocking tech has gotten better The Onion Router (TOR) # Web browser that communicates (encrypted) with a series of nodes that forward traffic, eventually to exit node and to unencrypted open internet TOR is in an arms race with the PRC; PRC tries to shut down TOR access .</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-11-10-encryption-and-technical-assistance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-11-10-encryption-and-technical-assistance/</guid><description> Encryption # US Encryption Law, 1970s-1990s # Encryption used to be regulated as a &amp;ldquo;munition&amp;rdquo; &amp;ldquo;Export-grade&amp;rdquo; cryptography forced by federal regulations to be weaker than cryptography for US market Regulations eventually relaxed around 2000 Still export controls for software with cryptographic functionality (but now loosening) Free-speech challenges by CS professors Bernstein v. U.S. DOJ (9th Cir. 1999) Junger v. Daley (6th Cir. 2000) Impact on modern-day web security FREAK attack (export-grade RSA) Logjam attack (export-grade Diffie-Hellman) DROWN attack (export-grade RSA)</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-11-15-malware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-11-15-malware/</guid><description>Malware # Definitions # Malware: umbrella term for malicious software
Virus: a malicious program that infects other program, usually spreading with human assistance Worm: a malicious program that spreads automatically, often without human intervention Trojan Horse: a malicious program that pretends to be something innocuous Rootkit: software that provides an adversary access to a computer in a hidden manner Specifically: control the computer at a system or kernel level RAT (Remote Access Toolkit): a rootkit that is often optimmized for ease-of-use A history of malware # Once upon a time (Commodore 64 era), viruses were carried on a floppy disk Inserting it would cycle colors and display a message At this time, there was no way to make money with malware, so viruses were mostly cute pranks Wipers: early destructive malware Floppy disk, would erase MSDOS disk The Morris Worm: the first fully automated worm Released by Robert Morris Jr.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-11-17-government-hacking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-11-17-government-hacking/</guid><description>Government Hacking # Specifically: governments hacking individuals for law enforcement purposes
Tools in law enforcement&amp;rsquo;s investigative toolbox (Easy to Hard)
Traditional evidence-gathering: warrants, ECPA, etc: Evidence is readily available Compelled technical assistance: Make provider repurpose a product feature for law enforcement purposes Government hacking: Using a bug for law enforcement purposes without provider participation Overview # Usual authority: search and seizure warrant (Fed. R. Crim. Pro. 41) Maybe no warrant needed if LE is only collecting IP address, according to multiple courts (have no reasonable expectation of privacy in IP address) State law may compel: Cal ECPA requires LE to get warrant for IP addresses Since Dec.</description></item><item><title/><link>https://saligrama.io/notes/intlpol268/2021-11-29-new-frontiers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/intlpol268/2021-11-29-new-frontiers/</guid><description>New Frontiers # China # 5 of the largest Internet platforms are Chinese TikTok: first to become dominant globally without Chinese government help PRC-based companies: Have to deal with political content moderation requirements Less experienced with safety issues as Western companies are Are not experienced with Western privacy laws Might store data in the PRC Could decide to not follow ECPA Crackdown on PRC-based tech CEOs that publicly disagree with CCP policies or that present a threat to Xi Jinping&amp;rsquo;s power Synthetic Media # Example: DNC email hack in 2016 Can create fake Facebook/Twitter profiles to mislead Types of abuse where falsity isn&amp;rsquo;t relevant to impact: Fake accounts Sextortion Harassment Spam Hate speech NCII These are ripe grounds for deepfakes IOT # Everything is a computer!</description></item></channel></rss>