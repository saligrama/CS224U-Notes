<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Dynamic Programming # Definitions # Dynamic programming: algorithmic design paradigm Usually for solving optimization problems (i.e., shortest path) Also useful for combinatorial problems (i.e., how many ways are there to achieve some task?) Elements of dynamic programming # Optimal sub-structure (necessary for DP to be correct) Big problems break up into subproblems e.g. Fibonacci (below): F(i) for i <= n e.g. Bellman-Ford (below): shortest paths with at most i edges for i <= n The solution to a problem can be expressed in terms of solutions to smaller subproblems e."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Dynamic Programming # Definitions # Dynamic programming: algorithmic design paradigm Usually for solving optimization problems (i.e., shortest path) Also useful for combinatorial problems (i.e., how many ways are there to achieve some task?) Elements of dynamic programming # Optimal sub-structure (necessary for DP to be correct) Big problems break up into subproblems e.g. Fibonacci (below): F(i) for i <= n e.g. Bellman-Ford (below): shortest paths with at most i edges for i <= n The solution to a problem can be expressed in terms of solutions to smaller subproblems e."><meta property="og:type" content="article"><meta property="og:url" content="https://saligrama.io/notes/cs161/2022-02-14-dynamic-programming/"><meta property="article:section" content="cs161"><title>Dynamic Programming | Aditya's notes</title><link rel=manifest href=/notes/manifest.json><link rel=icon href=/notes/favicon.png type=image/x-icon><link rel=stylesheet href=/notes/book.min.395a67680f48b8d23bbf267f26d0d1259e69554b2b704e371e8e15cbe656e05f.css integrity="sha256-OVpnaA9IuNI7vyZ/JtDRJZ5pVUsrcE43Ho4Vy+ZW4F8=" crossorigin=anonymous><script defer src=/notes/flexsearch.min.js></script>
<script defer src=/notes/en.search.min.2d7fe3a768fb0a28e9426a480cd2cbbe18eefbdb19eedae57337133d12dce08c.js integrity="sha256-LX/jp2j7CijpQmpIDNLLvhju+9sZ7trlczcTPRLc4Iw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/notes/><span>Aditya's notes</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-a88f46c31d1ebdf165810583424fda37 class=toggle>
<label for=section-a88f46c31d1ebdf165810583424fda37 class="flex justify-between"><a role=button>CS 103, Fall 2020</a></label><ul><li><a href=/notes/cs103/2020-09-16-set-theory/>Set Theory</a></li><li><a href=/notes/cs103/2020-09-18-indirect-proofs/>Indirect Proofs</a></li><li><a href=/notes/cs103/2020-09-18-mathematical-proofs/>Mathematical Proofs</a></li><li><a href=/notes/cs103/2020-09-26-first-order-logic/>First Order Logic</a></li><li><a href=/notes/cs103/2020-09-26-propositional-logic/>Propositional Logic</a></li><li><a href=/notes/cs103/2020-09-27-first-order-logic-continued/>First Order Logic Continued</a></li><li><a href=/notes/cs103/2020-09-30-binary-relations/>Binary Relations</a></li><li><a href=/notes/cs103/2020-10-01-binary-relations-continued/>Binary Relations Continued</a></li><li><a href=/notes/cs103/2020-10-04-functions/>Functions</a></li><li><a href=/notes/cs103/2020-10-10-cardinality/>Cardinality</a></li><li><a href=/notes/cs103/2020-10-11-graph-theory/>Graph Theory</a></li><li><a href=/notes/cs103/2020-10-17-pigeonhole-principle/>Pigeonhole Principle</a></li><li><a href=/notes/cs103/2020-10-18-induction/>Induction</a></li><li><a href=/notes/cs103/2020-10-19-induction-variants/>Induction Variants</a></li><li><a href=/notes/cs103/2020-10-20-computability-and-formal-languages/>Computability and Formal Languages</a></li><li><a href=/notes/cs103/2020-10-25-nondeterministic-finite-automata/>Nondeterministic Finite Automata</a></li><li><a href=/notes/cs103/2020-10-26-nfa-dfa-equivalence/>Nfa Dfa Equivalence</a></li><li><a href=/notes/cs103/2020-10-26-regular-expressions/>Regular Expressions</a></li><li><a href=/notes/cs103/2020-11-01-nonregular-languages/>Nonregular Languages</a></li><li><a href=/notes/cs103/2020-11-02-context-free-grammars/>Context Free Grammars</a></li><li><a href=/notes/cs103/2020-11-03-turing-machines/>Turing Machines</a></li><li><a href=/notes/cs103/2020-11-08-turing-machine-subroutines/>Turing Machine Subroutines</a></li><li><a href=/notes/cs103/2020-11-08-universal-turing-machine/>Universal Turing Machine</a></li><li><a href=/notes/cs103/2020-11-08-unsolvable-problems/>Unsolvable Problems</a></li><li><a href=/notes/cs103/2020-11-14-unsolvable-problems-continued/>Unsolvable Problems Continued</a></li></ul></li><li><input type=checkbox id=section-cf13475a7a80a5dd57b5a55dce73d171 class=toggle>
<label for=section-cf13475a7a80a5dd57b5a55dce73d171 class="flex justify-between"><a role=button>CS 107, Fall 2020</a></label><ul><li><a href=/notes/cs107/2020-09-18-integer-representations/>Integer Representations</a></li><li><a href=/notes/cs107/2020-09-21-bitwise-operations/>Bitwise Operations</a></li><li><a href=/notes/cs107/2020-09-25-c-chars-and-strings/>C Chars and Strings</a></li><li><a href=/notes/cs107/2020-09-28-more-c-strings/>More C Strings</a></li><li><a href=/notes/cs107/2020-10-02-pointers-arrays/>Pointers Arrays</a></li><li><a href=/notes/cs107/2020-10-05-stack-and-heap/>Stack and Heap</a></li><li><a href=/notes/cs107/2020-10-09-c-generics/>C Generics</a></li><li><a href=/notes/cs107/2020-10-12-function-pointers/>Function Pointers</a></li><li><a href=/notes/cs107/2020-10-16-assembly/>Assembly</a></li><li><a href=/notes/cs107/2020-10-19-assembly-arithmetic-logic/>Assembly Arithmetic Logic</a></li><li><a href=/notes/cs107/2020-10-23-assembly-control-flow/>Assembly Control Flow</a></li><li><a href=/notes/cs107/2020-10-26-assembly-function-calls-and-return-stack/>Assembly Function Calls and Return Stack</a></li><li><a href=/notes/cs107/2020-10-30-heap-management/>Heap Management</a></li><li><a href=/notes/cs107/2020-11-09-program-optimization/>Program Optimization</a></li></ul></li><li><input type=checkbox id=section-4e3bc6e2f7a0feae33c3e43356d49c80 class=toggle>
<label for=section-4e3bc6e2f7a0feae33c3e43356d49c80 class="flex justify-between"><a role=button>CS 110L, Spring 2021</a></label><ul><li><a href=/notes/cs110l/2021-03-30-course-overview/>Course Overview</a></li><li><a href=/notes/cs110l/2021-04-01-fixing-c/>Fixing C</a></li><li><a href=/notes/cs110l/2021-04-06-intro-to-rust/>Intro to Rust</a></li><li><a href=/notes/cs110l/2021-04-08-ownership/>Ownership</a></li><li><a href=/notes/cs110l/2021-04-13-error-handling/>Error Handling</a></li><li><a href=/notes/cs110l/2021-04-22-traits/>Traits</a></li><li><a href=/notes/cs110l/2021-04-27-generics/>Generics</a></li><li><a href=/notes/cs110l/2021-04-29-multiprocessing/>Multiprocessing</a></li></ul></li><li><input type=checkbox id=section-23e7773af736437c02202412a988f2db class=toggle>
<label for=section-23e7773af736437c02202412a988f2db class="flex justify-between"><a role=button>CS 111, Spring 2021</a></label><ul><li><a href=/notes/cs111/2021-03-31-threads-and-dispatching/>Threads and Dispatching</a></li><li><a href=/notes/cs111/2021-04-02-concurrency/>Concurrency</a></li><li><a href=/notes/cs111/2021-04-05-synchronization/>Synchronization</a></li><li><a href=/notes/cs111/2021-04-07-shared-memory-and-condition-variables-and-locks/>Shared Memory and Condition Variables and Locks</a></li><li><a href=/notes/cs111/2021-04-09-lock-implementation-and-deadlocking/>Lock Implementation and Deadlocking</a></li><li><a href=/notes/cs111/2021-04-12-scheduling/>Scheduling</a></li><li><a href=/notes/cs111/2021-04-14-multiprocessing/>Multiprocessing</a></li><li><a href=/notes/cs111/2021-04-16-linking/>Linking</a></li><li><a href=/notes/cs111/2021-04-19-storage-management/>Storage Management</a></li><li><a href=/notes/cs111/2021-04-21-virtual-memory/>Virtual Memory</a></li><li><a href=/notes/cs111/2021-04-23-dynamic-address-translation/>Dynamic Address Translation</a></li><li><a href=/notes/cs111/2021-04-26-segmentation-and-paging/>Segmentation and Paging</a></li><li><a href=/notes/cs111/2021-04-30-demand-paging/>Demand Paging</a></li><li><a href=/notes/cs111/2021-05-05-disks/>Disks</a></li><li><a href=/notes/cs111/2021-05-07-file-systems/>File Systems</a></li><li><a href=/notes/cs111/2021-05-10-realworld-filesystem-structures/>Realworld Filesystem Structures</a></li><li><a href=/notes/cs111/2021-05-12-directories/>Directories</a></li><li><a href=/notes/cs111/2021-05-14-crash-recovery/>Crash Recovery</a></li><li><a href=/notes/cs111/2021-05-19-protection/>Protection</a></li><li><a href=/notes/cs111/2021-05-24-flash-memory/>Flash Memory</a></li><li><a href=/notes/cs111/2021-05-28-virtual-machines/>Virtual Machines</a></li></ul></li><li><input type=checkbox id=section-a586b190ebf0a4874cd21a1d76743261 class=toggle>
<label for=section-a586b190ebf0a4874cd21a1d76743261 class="flex justify-between"><a role=button>CS 143, Spring 2022</a></label><ul><li><a href=/notes/cs143/2022-03-29-intro/>Intro</a></li><li><a href=/notes/cs143/2022-03-31-language-design-and-cool/>Language Design and Cool</a></li><li><a href=/notes/cs143/2022-04-05-lexical-analysis/>Lexical Analysis</a></li><li><a href=/notes/cs143/2022-04-07-lexical-analysis-implementation/>Lexical Analysis Implementation</a></li><li><a href=/notes/cs143/2022-04-12-parsing/>Parsing</a></li><li><a href=/notes/cs143/2022-04-14-syntax-directed-translation/>Syntax Directed Translation</a></li><li><a href=/notes/cs143/2022-04-19-top-down-parsing/>Top Down Parsing</a></li><li><a href=/notes/cs143/2022-04-26-semantic-analysis/>Semantic Analysis</a></li></ul></li><li><input type=checkbox id=section-37836de7a703e433b2642097d511f482 class=toggle>
<label for=section-37836de7a703e433b2642097d511f482 class="flex justify-between"><a role=button>CS 149, Fall 2022</a></label><ul><li><a href=/notes/cs149/2022-09-27-intro/>Intro</a></li><li><a href=/notes/cs149/2022-09-29-modern-multicore-processors/>Modern Multicore Processors</a></li><li><a href=/notes/cs149/2022-10-04-parallel-abstractions/>Parallel Abstractions</a></li><li><a href=/notes/cs149/2022-10-06-parallel-models/>Parallel Models</a></li><li><a href=/notes/cs149/2022-10-11-work-distribution-and-scheduling/>Work Distribution and Scheduling</a></li><li><a href=/notes/cs149/2022-10-13-locality-communication-and-contention/>Locality Communication and Contention</a></li><li><a href=/notes/cs149/2022-10-17-gpu-architecture-and-cuda/>Gpu Architecture and Cuda</a></li></ul></li><li><input type=checkbox id=section-4f9fa520660f975442d4640415905b3c class=toggle>
<label for=section-4f9fa520660f975442d4640415905b3c class="flex justify-between"><a role=button>CS 154, Fall 2021</a></label><ul><li><a href=/notes/cs154/2021-09-28-finite-automata/>Finite Automata</a></li><li><a href=/notes/cs154/2021-10-05-pumping-lemma-and-myhill-nerode/>Pumping Lemma and Myhill Nerode</a></li><li><a href=/notes/cs154/2021-10-12-streaming-algorithms-and-turing-machines/>Streaming Algorithms and Turing Machines</a></li></ul></li><li><input type=checkbox id=section-d24cd7d7d21fe73135d596a09b50887f class=toggle>
<label for=section-d24cd7d7d21fe73135d596a09b50887f class="flex justify-between"><a role=button>CS 155, Spring 2022</a></label><ul><li><a href=/notes/cs155/2022-03-28-intro/>Intro</a></li><li><a href=/notes/cs155/2022-03-30-control-hijacking/>Control Hijacking</a></li><li><a href=/notes/cs155/2022-04-04-control-hijacking-defenses/>Control Hijacking Defenses</a></li><li><a href=/notes/cs155/2022-04-06-security-principles/>Security Principles</a></li><li><a href=/notes/cs155/2022-04-11-isolation-and-sandboxing/>Isolation and Sandboxing</a></li><li><a href=/notes/cs155/2022-04-13-vuln-finding/>Vuln Finding</a></li><li><a href=/notes/cs155/2022-04-18-web-security/>Web Security</a></li><li><a href=/notes/cs155/2022-04-20-web-attacks/>Web Attacks</a></li><li><a href=/notes/cs155/2022-04-25-web-defenses/>Web Defenses</a></li><li><a href=/notes/cs155/2022-05-04-processor-security/>Processor Security</a></li><li><a href=/notes/cs155/2022-05-09-internet-protocol-security/>Internet Protocol Security</a></li></ul></li><li><input type=checkbox id=section-471622039e8d87cd8d642483c8d218b8 class=toggle checked>
<label for=section-471622039e8d87cd8d642483c8d218b8 class="flex justify-between"><a role=button>CS 161, Winter 2022</a></label><ul><li><a href=/notes/cs161/2022-01-03-intro/>Intro</a></li><li><a href=/notes/cs161/2022-01-05-worst-case-and-asymptotic-analysis/>Worst Case and Asymptotic Analysis</a></li><li><a href=/notes/cs161/2022-01-10-recurrence-relations/>Recurrence Relations</a></li><li><a href=/notes/cs161/2022-01-12-median-and-selection/>Median and Selection</a></li><li><a href=/notes/cs161/2022-01-19-randomized-algorithms-and-quicksort/>Randomized Algorithms and Quicksort</a></li><li><a href=/notes/cs161/2022-01-24-sorting-lower-bounds/>Sorting Lower Bounds</a></li><li><a href=/notes/cs161/2022-01-26-binary-search-trees/>Binary Search Trees</a></li><li><a href=/notes/cs161/2022-01-31-hashing/>Hashing</a></li><li><a href=/notes/cs161/2022-02-02-graphs-and-graph-search/>Graphs and Graph Search</a></li><li><a href=/notes/cs161/2022-02-07-strongly-connected-components/>Strongly Connected Components</a></li><li><a href=/notes/cs161/2022-02-09-weighted-graphs-and-dijkstra/>Weighted Graphs and Dijkstra</a></li><li><a href=/notes/cs161/2022-02-14-dynamic-programming/ class=active>Dynamic Programming</a></li><li><a href=/notes/cs161/2022-02-16-dynamic-programming-applications/>Dynamic Programming Applications</a></li><li><a href=/notes/cs161/2022-02-23-greedy-algorithms/>Greedy Algorithms</a></li><li><a href=/notes/cs161/2022-02-28-minimum-spanning-trees/>Minimum Spanning Trees</a></li></ul></li><li><input type=checkbox id=section-0794dc87987599843ba69a8ea82e9b6a class=toggle>
<label for=section-0794dc87987599843ba69a8ea82e9b6a class="flex justify-between"><a role=button>CS 224U, Spring 2021</a></label><ul><li><a href=/notes/cs224u/2021-03-29-course-overview/>Course Overview</a></li><li><a href=/notes/cs224u/2021-03-31-vector-space-models/>Vector Space Models</a></li><li><a href=/notes/cs224u/2021-04-12-sentiment-analysis/>Sentiment Analysis</a></li></ul></li><li><input type=checkbox id=section-efae8264f5fe410feb1b40be6f99baea class=toggle>
<label for=section-efae8264f5fe410feb1b40be6f99baea class="flex justify-between"><a role=button>CS 229, Fall 2021</a></label><ul><li><a href=/notes/cs229/2021-09-21-intro/>Intro</a></li><li><a href=/notes/cs229/2021-09-23-supervised-learning-setup/>Supervised Learning Setup</a></li><li><a href=/notes/cs229/2021-09-28-logistic-regression/>Logistic Regression</a></li><li><a href=/notes/cs229/2021-09-30-generalized-linear-models/>Generalized Linear Models</a></li><li><a href=/notes/cs229/2021-10-05-generative-learning-algorithms/>Generative Learning Algorithms</a></li><li><a href=/notes/cs229/2021-10-07-naive-bayes/>Naive Bayes</a></li><li><a href=/notes/cs229/2021-10-12-kernel-methods-and-svm/>Kernel Methods and Svm</a></li><li><a href=/notes/cs229/2021-10-14-deep-learning/>Deep Learning</a></li><li><a href=/notes/cs229/2021-10-19-deep-learning-optimization/>Deep Learning Optimization</a></li><li><a href=/notes/cs229/2021-10-21-model-selection/>Model Selection</a></li></ul></li><li><input type=checkbox id=section-292ea4e126876f1048e61c4dc744546c class=toggle>
<label for=section-292ea4e126876f1048e61c4dc744546c class="flex justify-between"><a role=button>CS 251, Fall 2022</a></label><ul><li><a href=/notes/cs251/2022-09-26-intro/>Intro</a></li><li><a href=/notes/cs251/2022-09-28-bitcoin-mechanics/>Bitcoin Mechanics</a></li><li><a href=/notes/cs251/2022-10-03-bitcoin-scripts-and-wallets/>Bitcoin Scripts and Wallets</a></li><li><a href=/notes/cs251/2022-10-05-consensus/>Consensus</a></li><li><a href=/notes/cs251/2022-10-10-internet-consensus/>Internet Consensus</a></li><li><a href=/notes/cs251/2022-10-17-ethereum/>Ethereum</a></li></ul></li><li><input type=checkbox id=section-98d861db134658b3e020a9d74c50ad24 class=toggle>
<label for=section-98d861db134658b3e020a9d74c50ad24 class="flex justify-between"><a role=button>CS 255, Winter 2022</a></label><ul><li><a href=/notes/cs255/2022-01-03-intro/>Intro</a></li><li><a href=/notes/cs255/2022-01-05-stream-ciphers/>Stream Ciphers</a></li><li><a href=/notes/cs255/2022-01-10-block-ciphers/>Block Ciphers</a></li><li><a href=/notes/cs255/2022-01-12-pseudorandom-functions/>Pseudorandom Functions</a></li><li><a href=/notes/cs255/2022-01-19-data-integrity-and-macs/>Data Integrity and Macs</a></li><li><a href=/notes/cs255/2022-01-24-collision-resistance/>Collision Resistance</a></li><li><a href=/notes/cs255/2022-01-26-authenticated-encryption/>Authenticated Encryption</a></li><li><a href=/notes/cs255/2022-01-31-key-management/>Key Management</a></li><li><a href=/notes/cs255/2022-02-02-key-exchange-math/>Key Exchange Math</a></li><li><a href=/notes/cs255/2022-02-07-public-key-encryption/>Public Key Encryption</a></li><li><a href=/notes/cs255/2022-02-09-pke-schemes/>Pke Schemes</a></li><li><a href=/notes/cs255/2022-02-14-digital-signatures/>Digital Signatures</a></li><li><a href=/notes/cs255/2022-02-16-certificates/>Certificates</a></li><li><a href=/notes/cs255/2022-02-23-id-protocols/>Id Protocols</a></li><li><a href=/notes/cs255/2022-02-28-key-exchange-protocols/>Key Exchange Protocols</a></li><li><a href=/notes/cs255/2022-03-02-zero-knowledge-protocols/>Zero Knowledge Protocols</a></li><li><a href=/notes/cs255/2022-03-07-quantum-cryptography/>Quantum Cryptography</a></li></ul></li><li><input type=checkbox id=section-568ed1bc8289796d56a6d06a22d7eb40 class=toggle>
<label for=section-568ed1bc8289796d56a6d06a22d7eb40 class="flex justify-between"><a role=button>INTLPOL 268, Fall 2021</a></label><ul><li><a href=/notes/intlpol268/2021-09-20-intro/>Intro</a></li><li><a href=/notes/intlpol268/2021-09-22-legal-intro-and-electronic-communications-privacy-act/>Legal Intro and Electronic Communications Privacy Act</a></li><li><a href=/notes/intlpol268/2021-09-27-web-requests-and-attacks/>Web Requests and Attacks</a></li><li><a href=/notes/intlpol268/2021-09-29-ecpa-for-private-actors/>Ecpa for Private Actors</a></li><li><a href=/notes/intlpol268/2021-10-04-cyberattacks/>Cyberattacks</a></li><li><a href=/notes/intlpol268/2021-10-06-computer-fraud-and-abuse-act/>Computer Fraud and Abuse Act</a></li><li><a href=/notes/intlpol268/2021-10-11-network-security/>Network Security</a></li><li><a href=/notes/intlpol268/2021-10-13-cfaa-dmca-and-security-research/>Cfaa Dmca and Security Research</a></li><li><a href=/notes/intlpol268/2021-10-20-data-security-laws/>Data Security Laws</a></li><li><a href=/notes/intlpol268/2021-10-25-corporate-intrusion/>Corporate Intrusion</a></li><li><a href=/notes/intlpol268/2021-10-27-ransomware-and-foreign-hackers/>Ransomware and Foreign Hackers</a></li><li><a href=/notes/intlpol268/2021-11-01-cryptography/>Cryptography</a></li><li><a href=/notes/intlpol268/2021-11-03-cyber-conflict/>Cyber Conflict</a></li><li><a href=/notes/intlpol268/2021-11-08-dark-web-and-cryptocurrencies/>Dark Web and Cryptocurrencies</a></li><li><a href=/notes/intlpol268/2021-11-10-encryption-and-technical-assistance/>Encryption and Technical Assistance</a></li><li><a href=/notes/intlpol268/2021-11-15-malware/>Malware</a></li><li><a href=/notes/intlpol268/2021-11-17-government-hacking/>Government Hacking</a></li><li><a href=/notes/intlpol268/2021-11-29-new-frontiers/>New Frontiers</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/notes/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Dynamic Programming</strong>
<label for=toc-control><img src=/notes/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#dynamic-programming>Dynamic Programming</a><ul><li><a href=#definitions>Definitions</a></li><li><a href=#elements-of-dynamic-programming>Elements of dynamic programming</a></li><li><a href=#example-fibonacci-numbers>Example: Fibonacci numbers</a><ul><li><a href=#recursive-algorithm-ie-week-1>Recursive algorithm (i.e., Week 1):</a></li><li><a href=#instead-memoize-the-previous-fibonacci-calls>Instead: memoize the previous fibonacci calls</a></li><li><a href=#bottom-up-dp>Bottom-up DP</a></li><li><a href=#top-down-dp>Top-down DP</a><ul><li><a href=#top-down-example>Top-down example</a></li></ul></li></ul></li><li><a href=#example-bellman-ford-algorithm>Example: Bellman-Ford algorithm</a><ul><li><a href=#motivation-dijkstra-drawbacks>Motivation: Dijkstra drawbacks</a></li><li><a href=#difference-between-bellman-ford-and-dijkstra>Difference between Bellman-Ford and Dijkstra:</a></li><li><a href=#pseudocode>Pseudocode</a></li><li><a href=#correctness>Correctness</a></li><li><a href=#runtime>Runtime</a></li></ul></li><li><a href=#floyd-warshall-algorithm>Floyd-Warshall Algorithm</a><ul><li><a href=#psuedocode>Psuedocode</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=dynamic-programming>Dynamic Programming
<a class=anchor href=#dynamic-programming>#</a></h1><h2 id=definitions>Definitions
<a class=anchor href=#definitions>#</a></h2><ul><li>Dynamic programming: algorithmic design paradigm</li><li>Usually for solving optimization problems (i.e., shortest path)<ul><li>Also useful for combinatorial problems (i.e., how many ways are there to achieve <em>some task</em>?)</li></ul></li></ul><h2 id=elements-of-dynamic-programming>Elements of dynamic programming
<a class=anchor href=#elements-of-dynamic-programming>#</a></h2><ol><li>Optimal sub-structure (necessary for DP to be correct)<ul><li>Big problems break up into subproblems<ul><li>e.g. Fibonacci (below): F(i) for <em>i &lt;= n</em></li><li>e.g. Bellman-Ford (below): shortest paths with at most <em>i</em> edges for <em>i &lt;= n</em></li></ul></li><li>The solution to a problem can be expressed in terms of solutions to smaller subproblems<ul><li>e.g. Fibonacci: <em>F(i+1) = F(i) + F(i-1)</em></li><li>e.g. Bellman-Ford: <em>d[v] = min(d[v], minu d[u] + w(u, v)</em>)</li></ul></li></ul></li><li>Overlapping sub-problems (necessary for DP to achieve speedup)<ul><li>e.g. Fibonacci: Both <em>F[i+2]</em> and <em>F[i+1]</em> directly use <em>F[i]</em>; many <em>F[i+x]</em> indirectly use <em>F[i]</em></li><li>e.g. Bellman-Ford: many different entries of <em>d</em> at step <em>i+1</em> will use <em>d[v]</em> at step <em>i</em>; lots of entries of <em>d</em> at step <em>i+x</em> will indirectly do so</li></ul></li></ol><h2 id=example-fibonacci-numbers>Example: Fibonacci numbers
<a class=anchor href=#example-fibonacci-numbers>#</a></h2><h3 id=recursive-algorithm-ie-week-1>Recursive algorithm (i.e., Week 1):
<a class=anchor href=#recursive-algorithm-ie-week-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>fibonacci</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> fibonacci(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>+</span> fibonacci(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>)
</span></span></code></pre></div><ul><li>Runtime: exponential.</li><li>Note: this does a lot of repeated computation!<ul><li>For <code>fibonacci(8)</code> we calculate <code>fibonacci(2)</code> 11 times (and <code>fibonacci(1)</code> and <code>fibonacci(0)</code> even more!)</li></ul></li></ul><h3 id=instead-memoize-the-previous-fibonacci-calls>Instead: memoize the previous fibonacci calls
<a class=anchor href=#instead-memoize-the-previous-fibonacci-calls>#</a></h3><p>Memoization: keeping track of previous function calls, usually in an array or other data structure</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>fasterFibonacci</span>(n):
</span></span><span style=display:flex><span>    F <span style=color:#ff79c6>=</span> [<span style=color:#ff79c6>None</span>] <span style=color:#ff79c6>*</span> (n<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>    F[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    F[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#bd93f9>2</span>, n<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>):
</span></span><span style=display:flex><span>        F[i] <span style=color:#ff79c6>=</span> F[i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>+</span> F[i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>]
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> F[n]
</span></span></code></pre></div><h3 id=bottom-up-dp>Bottom-up DP
<a class=anchor href=#bottom-up-dp>#</a></h3><ul><li>Like what we see for Fibonacci and Bellman-Ford<ul><li>Solve smaller problems first (F[0] or <em>d</em> at step [0], then F[1] or <em>d</em> at step 1, then&mldr;) then bigger problems, then the full problem (<em>F(n)</em> or <em>d</em> at step <em>n-1</em>)</li></ul></li><li>Preferable if we know recursion might get extremely deep (i.e., lots of variables to recurse over in algorithm/subproblem state) - that way, we don&rsquo;t overwhelm the function call stack</li></ul><h3 id=top-down-dp>Top-down DP
<a class=anchor href=#top-down-dp>#</a></h3><ul><li>Adding memoization to previous divide-and-conquer methods</li><li>To solve big problems:<ul><li>Recurse to solve smaller probelms<ul><li>Then recurse to solve even smaller problems<ul><li>etc&mldr;</li></ul></li></ul></li></ul></li><li>Keep track of what small problems you&rsquo;ve already solved to prevent re-solving the same problem twice</li><li>Preferable if we know that the recursion doesn&rsquo;t need to compute certain subproblems</li></ul><h4 id=top-down-example>Top-down example
<a class=anchor href=#top-down-example>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>F <span style=color:#ff79c6>=</span> [<span style=color:#ff79c6>None</span>] <span style=color:#ff79c6>*</span> (n<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>F[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>F[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>Fibonacci</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> F[n] <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> F[n]
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> Fibonacci(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>+</span> Fibonacci(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>)
</span></span></code></pre></div><h2 id=example-bellman-ford-algorithm>Example: Bellman-Ford algorithm
<a class=anchor href=#example-bellman-ford-algorithm>#</a></h2><h3 id=motivation-dijkstra-drawbacks>Motivation: Dijkstra drawbacks
<a class=anchor href=#motivation-dijkstra-drawbacks>#</a></h3><ul><li>Needs non-negative edge weights</li><li>If the weights change, need to re-run the whole algorithm</li></ul><h3 id=difference-between-bellman-ford-and-dijkstra>Difference between Bellman-Ford and Dijkstra:
<a class=anchor href=#difference-between-bellman-ford-and-dijkstra>#</a></h3><ul><li>Bellman-Ford is slower than Dijkstra</li><li>Bellman-Ford can handle negative edge weights<ul><li>Can detect negative cycles (i.e., path from a->b->c->a has less cost than zero)</li><li>Can be useful if we want to say some edges are actively helpful to take, rather than costly</li><li>Can be useful as a building block in other algorithms</li></ul></li><li>Allows some flexibility if weights change</li></ul><p>Bellman-Ford intuition: Instead of picking the node <em>u</em> with the smallest <em>d[u]</em>, update all the node weights at once</p><h3 id=pseudocode>Pseudocode
<a class=anchor href=#pseudocode>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>bellmanFord</span>(V, E, s):
</span></span><span style=display:flex><span>    d <span style=color:#ff79c6>=</span> [INT_MAX] <span style=color:#ff79c6>*</span> <span style=color:#8be9fd;font-style:italic>len</span>(V)
</span></span><span style=display:flex><span>    d[s] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>len</span>(V) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (u, v, w) <span style=color:#ff79c6>in</span> E: <span style=color:#6272a4># u src, v dst, w weight</span>
</span></span><span style=display:flex><span>            d[v] <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>min</span>(d[v], d[u] <span style=color:#ff79c6>+</span> w)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> d
</span></span></code></pre></div><h3 id=correctness>Correctness
<a class=anchor href=#correctness>#</a></h3><p><strong>Inductive hypothesis</strong>: At each step <em>i</em>, <em>d[v]</em> is equal to the cost of the shortest path between <em>s</em> and <em>v</em> of length at most <em>i</em> edges</p><p><strong>Base case</strong>: 0; vacuously true (0 edges -> infinite cost)</p><p><strong>Inductive step</strong>: Suppose IH applies for <em>0 &lt;= n &lt;= k</em>; then at step <em>k</em> for all <em>v</em>, <em>d[v]</em> is the shortest path between <em>s</em> and <em>v</em> with at most <em>k</em> edges. Suppose we do a <em>k+1</em> iteration, then we can choose to take any <em>u</em> as an additional intermediate between <em>s</em> and <em>v</em> or not; thus the path will be the same or shorter than before and have at most <em>k+1</em> edges.</p><p><strong>Conclusion</strong>: At step <em>|V|-1</em>, for each <em>v</em>, <em>d[v]</em> is equal to the cost of the shortest path between <em>s</em> and <em>v</em> of length at most <em>|V|-1</em> edges (which is the absolute shortest path).</p><h3 id=runtime>Runtime
<a class=anchor href=#runtime>#</a></h3><p>One loop for edges (<em>|E|</em>) inside a loop for vertices (<em>|V|</em>) -> O(|V||E|)</p><h2 id=floyd-warshall-algorithm>Floyd-Warshall Algorithm
<a class=anchor href=#floyd-warshall-algorithm>#</a></h2><p>Algorithm for All-Pairs Shortest Paths</p><ul><li>Need to know shortest path from <em>u</em> to <em>v</em> for all pairs <em>(u, v)</em> of vertices in the graph (not just from a special single source <em>s</em>)</li><li>Brute force: run Dijkstra from all nodes <em>s</em>: this takes time O(|V||E| log|V|)<ul><li>If negative edge weights: need Bellman-Ford, this takes time O(|V|2|E|)</li></ul></li><li>Floyd-Warshall intuition: for each node <em>k</em>, check if the distance between each pair of nodes <em>i</em> and <em>j</em> can be reduced by using <em>k</em> as an intermediate<ul><li>Just like Bellman-Ford: idea is to calculate shortest path between <em>i</em> and <em>j</em> for each <em>(i, j)</em> with at most <em>h</em> edges at each step <em>h</em></li><li>Runtime: O(|V|3)<ul><li>Better than running Bellman-Ford <em>n</em> times</li><li>However: if no negative edge weights and the graph is not extremely dense, better to run Dijkstra with a min-heap</li></ul></li><li>Space complexity: O(|V|2)</li></ul></li></ul><h3 id=psuedocode>Psuedocode
<a class=anchor href=#psuedocode>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>dist <span style=color:#ff79c6>=</span> [[INF] <span style=color:#ff79c6>*</span> <span style=color:#8be9fd;font-style:italic>len</span>(V)] <span style=color:#ff79c6>*</span> <span style=color:#8be9fd;font-style:italic>len</span>(V)
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>len</span>(V)):
</span></span><span style=display:flex><span>    d[i][i] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> k <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>len</span>(V)):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>len</span>(V)):
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> j <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>len</span>(V)):
</span></span><span style=display:flex><span>            d[i][j] <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>min</span>(d[i][j], d[i][k] <span style=color:#ff79c6>+</span> d[k][j])
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#dynamic-programming>Dynamic Programming</a><ul><li><a href=#definitions>Definitions</a></li><li><a href=#elements-of-dynamic-programming>Elements of dynamic programming</a></li><li><a href=#example-fibonacci-numbers>Example: Fibonacci numbers</a><ul><li><a href=#recursive-algorithm-ie-week-1>Recursive algorithm (i.e., Week 1):</a></li><li><a href=#instead-memoize-the-previous-fibonacci-calls>Instead: memoize the previous fibonacci calls</a></li><li><a href=#bottom-up-dp>Bottom-up DP</a></li><li><a href=#top-down-dp>Top-down DP</a><ul><li><a href=#top-down-example>Top-down example</a></li></ul></li></ul></li><li><a href=#example-bellman-ford-algorithm>Example: Bellman-Ford algorithm</a><ul><li><a href=#motivation-dijkstra-drawbacks>Motivation: Dijkstra drawbacks</a></li><li><a href=#difference-between-bellman-ford-and-dijkstra>Difference between Bellman-Ford and Dijkstra:</a></li><li><a href=#pseudocode>Pseudocode</a></li><li><a href=#correctness>Correctness</a></li><li><a href=#runtime>Runtime</a></li></ul></li><li><a href=#floyd-warshall-algorithm>Floyd-Warshall Algorithm</a><ul><li><a href=#psuedocode>Psuedocode</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>