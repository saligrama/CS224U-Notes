<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS 161, Winter 2022 on Aditya's notes</title><link>https://saligrama.io/notes/cs161/</link><description>Recent content in CS 161, Winter 2022 on Aditya's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://saligrama.io/notes/cs161/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://saligrama.io/notes/cs161/2022-01-03-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-03-intro/</guid><description>CS 161 Design and Analysis of Algorithms # About the course # Course goals # The design and analysis of algorithms These go hand in hand In this course Learn to think analytically about algorithms Flesh out an &amp;ldquo;algorithmic toolkit&amp;rdquo; Learn to communicate clearly about algorithms Guiding questions # Does it work? Is it fast? Can I do better? Should it work? Should it be fast? Logistics # Lectures</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-05-worst-case-and-asymptotic-analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-05-worst-case-and-asymptotic-analysis/</guid><description>Worst-case and asymptotic analysis # Worst-case analysis # An algorithm must be correct on all possible inputs The running time of the algorithm is the worst possible running time over all inputs That is, if we design a purposefully adversarial input, the algorithm should still work on that input Pro and con: very strong guarantee Asymptotic analysis: Big-O notation # Meaningful way to talk about the runtime of an algorithm, independent of programming language or computing platform, without having to count all of the operations Focuses on how the runtime scales with input size n Highest-degree term in the sum is the only one that counts e.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-10-recurrence-relations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-10-recurrence-relations/</guid><description> Recurrence relations # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-12-median-and-selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-12-median-and-selection/</guid><description>The k-SELECT problem # Let A be an array of integers and let k be an integer Goal: Return the k&amp;rsquo;th smallest element of A e.g. A = [7, 4, 3, 8, 1, 5, 9, 14] SELECT(A, 1) = 1 SELECT(A, 2) = 3 SELECT(A, 3) = 4 SELECT(A, 8) = 14 SELECT(A, 1) = MIN(A) SELECT(A, n/2) = MEDIAN(A) O(n log n) algorithm # Very simple! Sort the array, return A[k-1] What we want: an O(n) algorithm # Ex.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-19-randomized-algorithms-and-quicksort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-19-randomized-algorithms-and-quicksort/</guid><description>Randomized Algorithms # Idea: make random choices during the algorithm
Hope the algorithm works Hope the algorithm is fast Today: look at algorithms that always work and are probably fast
e.g. select with random pivot Analysis of randomized algorithms # Scenario 1: publish algorithm, adversarially picked input, run algorithm (expected running time - as a random variable)
Scenario 2: publish algorithm, adversarially picked input and randomness (worst-case analysis)
Bogosort # Algorithm BogoSort(A):</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-24-sorting-lower-bounds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-24-sorting-lower-bounds/</guid><description>Sorting lower bounds # Defining a valid sorting algorithm # Comparison-based model of computation (requires 立(n log n) steps):
Input: array Output: sorted array Operations allowed: comparisons Another model:
CountingSort and RadixSort Run in time O(n) 立(n log n) bound for comparison sorting # Theorem:
Any deterministic comparison-based sorting algorithm must take 立(n log n) steps Any randomized comparison-based sorting algorithm must take 立(n log n) steps in expectation Argument:</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-26-binary-search-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-26-binary-search-trees/</guid><description> Binary search trees # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-01-31-hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-01-31-hashing/</guid><description>Hashing # Generic data structure that allows fast insert/delete/search Doesn&amp;rsquo;t need items to be comparable, only hashable Idea: get better performance in expectation using randomness Primitive: direct addressing # Suppose all keys are in the set {1..9} Create buckets 1..9 Insert: map key i to bucket i Delete: remove from bucket i Search: look for bucket i Problem: if keys are arbitrary, this requires a lot of memory
An improvement: put items in buckets based on one digit</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-02-graphs-and-graph-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-02-graphs-and-graph-search/</guid><description> Graphs and graph search (BFS and DFS) # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-07-strongly-connected-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-07-strongly-connected-components/</guid><description> Strongly connected components # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-09-weighted-graphs-and-dijkstra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-09-weighted-graphs-and-dijkstra/</guid><description> Weighted graphs and Dijkstra&amp;rsquo;s algorithm # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-14-dynamic-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-14-dynamic-programming/</guid><description>Dynamic Programming # Definitions # Dynamic programming: algorithmic design paradigm Usually for solving optimization problems (i.e., shortest path) Also useful for combinatorial problems (i.e., how many ways are there to achieve some task?) Elements of dynamic programming # Optimal sub-structure (necessary for DP to be correct) Big problems break up into subproblems e.g. Fibonacci (below): F(i) for i &amp;lt;= n e.g. Bellman-Ford (below): shortest paths with at most i edges for i &amp;lt;= n The solution to a problem can be expressed in terms of solutions to smaller subproblems e.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-16-dynamic-programming-applications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-16-dynamic-programming-applications/</guid><description>Applications of Dynamic Programming # Longest Common Subsequence # Definition # Subsequence: chosen sequential subset of a sequence e.g.: BDFH is a subsequence of ABCDEFGH If X, Y are sequences, a common sequence that is a subsequence of both e.g. BDFH is a subsequence of ABCDEFGH and of ABDFGHI Longest common subsequence (LCS) is a common subsequence that is the longest e.g. ABDFGH is the LCS of of ABCDEFGH and of ABDFGHI Dynamic programming steps # Optimal substructure Subproblems will be finding LCS&amp;rsquo;s of prefixes to X and Y Let C[i, j] = length_of_LCS(X[i], Y[j]) Case 1: X[i] = Y[j] Then C[i, j] = 1 + C[i-1,j-1] (because we can continue the previous subsequences by adding the new common character) Case 2: X[i] !</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-23-greedy-algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-23-greedy-algorithms/</guid><description>Greedy Algorithms # Idea:
Make choices one-at-a-time Never look back Hope for the best However: does not work everywhere.
When to use greedy algorithms? # Problem should exhibit optimal substructure:
Optimal solutions to a problem are made up from optimal solutions of subproblems Each problem depends on only one subproblem Common strategy for proving correctness # Make a series of choices Suppose we&amp;rsquo;re on track to make optimal solution T* Show that at each step, choices won&amp;rsquo;t rule out a globally optimal solution Suppose that T* disagrees with the next greedy choice Manipulate T* in order to make a solution T that&amp;rsquo;s not worse but agrees with the next greedy choice Swap choice k instead of choice j After having made all choices, we haven&amp;rsquo;t ruled out an optimal solution, so the solution we found is optimal This can be turned into an inductive proof.</description></item><item><title/><link>https://saligrama.io/notes/cs161/2022-02-28-minimum-spanning-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs161/2022-02-28-minimum-spanning-trees/</guid><description> Minimum spanning trees # Previous Next &amp;nbsp; &amp;nbsp; Page: /</description></item></channel></rss>