<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS 155, Spring 2022 on Aditya's notes</title><link>https://saligrama.io/notes/cs155/</link><description>Recent content in CS 155, Spring 2022 on Aditya's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://saligrama.io/notes/cs155/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://saligrama.io/notes/cs155/2022-03-28-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-03-28-intro/</guid><description>Computer and Network Security: Overview # The computer security problem # Lots of buggy software Money can be made from finding and exploiting vulns Marketplace for exploits (gaining a foothold) Marketplace for malware (post-compromise) Strong economic and political motivation for using both Current state: Existence of vulns is somewhat evenly distributed across OS&amp;rsquo;s Usage of exploits: almost 50% start by attacking Microsoft Office; 32% start by attacking the browser Course goals # Understand exploit techniques Learn to defend and prevent common exploits Understand available security tools Learn to architect secure systems This course # Part 1: basics (architecting for security) Securing apps, OS, and legacy code: sandboxing, access control, and security testing Part 2: Web security (defending against a web attacker) Building robust websites, understanding the browser security model Part 3: network security (defending against a network attacker) Monitoring and architecting secure networks Part 4: securing mobile applications Course introduction: what motivates attackers?</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-03-30-control-hijacking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-03-30-control-hijacking/</guid><description>Basic Control Hijacking Attacks # Attacker&amp;rsquo;s goal: Take over target machine (e.g., web server) Execute arbitrary code on target by hijacking application control flow Examples: Buffer overflow and integer overflow attacks Format string vulnerabilities Use after free Buffer overflow attacks # Extremely common in C/C++ programs Now advised to avoid C/C++ Use Rust: typesystem should help avoid these bugs First major exploit: 1988 internet worm, bug in fingerd What is needed:</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-04-control-hijacking-defenses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-04-control-hijacking-defenses/</guid><description>Control Hijacking Defenses # Note: control hijacking attacks occur because data is mixed with control flow in memory -&amp;gt; allows attackers to mess with control flow by manipulating data
Ways to prevent control hijacking attacks:
Fix bugs Audit software: automated tools include Coverity, Infer, etc. Rewrite software in a type-safe language (Java, Go, Rust) - however this is difficult for existing/legacy code Platform defenses: prevent attack code execution Harden executable to detect control hijacking Halt processes and report when exploit detected e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-06-security-principles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-06-security-principles/</guid><description>Principles of secure systems # Inevitability of vulnerabilities # Very easy to make mistakes involving buffer overflow, use-after-free, or null pointer dereferences Many such mistakes can allow attackers to run malicious code As such, there will always be bugs, even as we get better at finding and preventing them Systems must be designed to be resilient in the face of both software vulnerabilities and malicious users Defense in Depth # Systems should be built with security protections at multiple layers e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-11-isolation-and-sandboxing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-11-isolation-and-sandboxing/</guid><description>Isolation and Sandboxing # Goal: run untrusted code without compromising systems
Programs from untrusted Internet sites Mobile apps, JS, browser extensions Exposed applications: Browser, PDF viewer, email client Legacy daemons: sendmail, bind Honeypots If application misbehaves, want to kill it Approach: confinement # Idea: ensure misbehaving app cannot harm rest of system Can be implemented at many levels Hardware: run application on isolated hardware (airgap) - difficult to manage Virtual machines: isolate OS&amp;rsquo;s on a single machine Process level: system call interposition; isolate a process in a single OS Threads: software fault isolation (SFI) Isolating threads sharing same address space Application level confinement e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-13-vuln-finding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-13-vuln-finding/</guid><description>Finding vulnerabilities using fuzzing, dynamic, and static analysis # Conceptualizing vulnerabilities # Computer programs can be thought of as finite state machines The code we want to write represents states we intend to reach However, code can also have unintended states if miswritten Bugs exist when there are reachable states in the runnable state machine (the code) that have no corresponding state in the intended state machine (the design) Vulnerabilities live in this unintended space; exploitation is making the program do &amp;ldquo;interesting&amp;rdquo; transitions in the unintended state space Types of bugs: Design issue: the conceptual state machine does not meet intended goals e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-18-web-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-18-web-security/</guid><description>Web Security Model # Web security goals # Safely browse the web: Sites should not be able to steal data from device, install malware, access camera, etc Sites should not be able to affect or eavesdrop on other sessions Support secure high-performance web apps Web-based applications should have same or better security properties as desktop applications Attack models # Malicious website Malicious external resources Network attacker Malware attacker HTTP protocol # ASCII protocol from 1989 that allows fetching resources (e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-20-web-attacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-20-web-attacks/</guid><description>Web Attacks # Cookie Attack # Suppose CS155 allows you to login and submit homework at cs155.stanford.edu Login with username and password; cs155.stanford.edu responds with cookies: session=abc Now access dabo.stanford.edu/memes, dabo.stanford.edu sets cookie to cookies: session=def for Domain=stanford.edu Now browser will send both session cookies, and it is up to server to determine which is correct Cross-Site Request Forgery # Type of web exploit where a website transmits unauthorized commands as a user that the web app trusts In CSRF attack, user is tricked into submitting an unintended/unrealized request to website Cookie-based authentication is not sufficient for requests that have any side effect Preventing CSRF attacks: Referer validation Secret validation token Custom HTTP header sameSite cookies Referer validation # Referer header contains address of previous web page from which a link to currently requested page was followed Allows servers to identify where people are visiting from https://bank.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-04-25-web-defenses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-04-25-web-defenses/</guid><description>Authentication and Session Management # Pre-history: HTTP auth # HTTP request: GET /index.html HTTP response contains: WWW-Authenticate: Basic realm=&amp;quot;Password Required&amp;quot; Browser sends hashed password on all subsequent HTTP requests Caveats: User cannot log out other than by closing browser What if user has multiple accounts? Site cannot customize password dialog Confusing dialog to users Easily spoofed Modern session management # Login # When visiting website, site creates anonymous session and hands session ID back in a cookie User will POST with username and password, website checks credentials and elevates token to logged-in Logout # Delete session token from client Mark session token as expired on server Authenticating users # First idea: plaintext passwords (terrible) Store password and check match against user input Don&amp;rsquo;t trust anything that provides you your password Second idea: store password hash (bad) Store SHA-1(pw) and check match against SHA-1(input) Weak against attacker who has hashed common passwords Third idea: store salted hash (better) Store (r, SHA-1(pw + r)) and check against SHA-1(input + r) Prevents attackers from precomputing password hashes Need to make sure to choose a hash function that is expensive to compute In practice: use bcrypt, scrypt, or pbkdf2 when building an application Phishing attacks # Attacker sends a fraudulent message that tricks user into revealing sensitive data (e.</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-05-04-processor-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-05-04-processor-security/</guid><description>Processor security # The processor # Part of the trusted computing base (TCB) But is optimized for performance Security may be secondary Processor design and security: Important security features Hardware enclaves Memory encryption (TME) RDRAND etc. Some features can be exploited for attacks Speculative execution Transactional memory Intel Software Guard eXstensions (SGX) # Extension to Intel processors that support Enclaves: running code and memory isolated from rest of system Attestation: prove to local/remote system what code is running in enclave Minimum TCB: only processor is trusted and nothing else DRAM and peripherals are untrusted Writes to memory are encrypted Applications Storing a web server HTTPS secret key: secret key only opened inside an enclave Malware cannot get the key Note: this is different from TPM2 - TPM2 only provides secure storage at boot, after that it&amp;rsquo;s all in memory Running a private job in the cloud: job runs in enclave Cloud admin cannot get code or data or job Client side: hide antivirus signatures AV signatures are only opened inside an enclave Data science on federated data Compute on shared data, without ever having to share the data with anyone else SGX now deprecated in consumer CPUs, only available in server CPUs SGX enclaves # Application defines part of itself as an enclave Untrusted part of memory creates enclave Enclave is isolated memory in process memory space Inaccessible while processor is not in SGX mode Untrusted part can call a trusted function in the enclave To do execution, processor goes into SGX mode Creating en enclave: ECREATE: establish mem addr for enclave EADD: copy memory pages into enclave EEXTEND: compute hash of enclave contents, 256 bytes at a time EINIT: verifies that hashed content is properly signed; if so, initializes enclave (signature: RSA3072) EENTER: call function inside enclave EEXIT: return from enclave SGX attestation # Problem: enclave memory is in the clear prior to activation (EINIT) How to get secrets into enclave?</description></item><item><title/><link>https://saligrama.io/notes/cs155/2022-05-09-internet-protocol-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs155/2022-05-09-internet-protocol-security/</guid><description>Internet Protocol Security # The Internet # Global protocol that provides best-effort delivery of packet between connected hosts Packet: structured sequence of bytes Header: metadata used by network Payload: user data to be transported Every host has a unique identifier - IP address Series of routers receive packets, look at header destination address, and send it one hop towards destination IP address Network protocols # Define how hosts communicate in published network protocols Syntax: how communication is structured (e.</description></item></channel></rss>