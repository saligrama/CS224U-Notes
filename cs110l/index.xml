<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS 110L, Spring 2021 on Aditya's notes</title><link>https://saligrama.io/notes/cs110l/</link><description>Recent content in CS 110L, Spring 2021 on Aditya's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://saligrama.io/notes/cs110l/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://saligrama.io/notes/cs110l/2021-03-30-course-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-03-30-course-overview/</guid><description>Course info # Course site: cs110l.stanford.edu
Topics # How to prevent common mistakes in systems programming?
Memory safety and common errors in C/C++ Preventing common memory safety errors in Rust Avoiding multiprocessing pitfalls Avoiding multithreading pitfalls Networked systems Grading # Course is pass/fail and the pass threshold is 70%
Components:
Lecture (2x 50min/week) Weekly exercises (40%) Small programming problems to reinforce week&amp;rsquo;s lecture material Alternatively: blog posts about course material Expected time: 1-3 hours per week Projects (40%) Mini GDB High-performance web server Participation (20%) Why Rust?</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-01-fixing-c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-01-fixing-c/</guid><description>C/C++ tools for code safety # Dynamic analysis # Valgrind # On-the fly instrumentation of binaries Works with all binaries compiled by all compilers, even without source code/debug symbols Drawback: Not much information in binaries; no information about stack allocation (so no detection of stack buffer overflows) LLVM sanitizers # Instrumentation of source code Provided by LLVM compiler suite (i.e., Clang) More information because source code is instrumented rather than binaries Examples:</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-06-intro-to-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-06-intro-to-rust/</guid><description>Why Rust (from a memory perspective) # What makes good code?
Pre/post conditions to break code into small pieces with well-defined interfaces in between Want to reason about small pieces in isolation If pre/post conditions of each piece is held up in isolation, then simply stringing them together works without having to keep entirety of program in one&amp;rsquo;s head Code with good memory management clearly defines how memory is passed around and &amp;ldquo;who&amp;rdquo; is responsible for cleaning it up C/C++&amp;rsquo;s compiler cannot effectively verify pre/post conditions with regards to memory.</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-08-ownership/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-08-ownership/</guid><description>Drop trait # drop function called at end of scope (designated by curly braces) Special function that properly frees an entire object (maybe multiple pointers to free) Similar to C++ destructor Classes that implement a drop function have a Drop trait fn main() { let a = &amp;#34;Hello, world!&amp;#34;.to_string(); let b = a; } // a, b dropped here: drop only called on b Copy trait # Some values in Rust don&amp;rsquo;t use the heap and are stored directly on the stack (integer types, booleans, etc) These are copied by default when assigning variables, so drop doesn&amp;rsquo;t need to be called Types with this property have the Copy trait If a type has the Copy trait, it cannot also have the Drop trait Variable rules # All pieces of data in Rust are by default immutable (i.</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-13-error-handling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-13-error-handling/</guid><description>Error handling # Error handling in C # If a function can encounter an error, its return type is int or void * If successful, it returns 0, otherwise, returns -1 (or valid pointer/NULL) Function that encountered error sets global variable errno to be an integer indicating what went wrong (many such codes). If -1 or NULL was returned, caller should check errno. Heavy burden on programmer to remember how each specific function works Handling specific errors using errno creates mess of if statements Error handling using exceptions (most languages including C++) # Error happens: error propagates up the stack until handled by try/catch or reaches main and crashes program Errors will not go unnoticed, unlike C: avoids undefined behavior Disadvantages: Overhead in terms of code size Failure modes become hard to reason about; any function can throw any exception at any time Error handling in Rust # Enum (enumeration) # Type that can contain one of several variants enum TrafficLightColor { Red, Yellow, Green, } let current_state : TrafficLightColor = TrafficLightColor::Green; Match expression: like a switch statement, but all possible variants must be covered.</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-22-traits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-22-traits/</guid><description>Traits # Create functions that we want classes to duplicate (or redefine), but outside a super class Code gets injected into any existing structure (both custom types and standard ones) Trait methods do not need to be fully defined, can define stub methods/declarations Data is not inherited Advantages:
Code reuse: Can create trait with parametrized functions implemented differently for different traits Code hiding: All parts of a trait are exposed, but we can specify exactly which functions should be injected, so no accidental spillover Example:</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-27-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-27-generics/</guid><description>Generics # Allow us to factor out types and write less code No performance impact at runtime: compiler creates separate functions for types that are used Example:
fn foo&amp;lt;T&amp;gt;(x : T, y : T) -&amp;gt; T { // do something } fn main() { let x, y : usize = // some vals foo(x, y); let a, b : f32 = // some vals foo(a, b); } We can put constraints on the input types:</description></item><item><title/><link>https://saligrama.io/notes/cs110l/2021-04-29-multiprocessing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://saligrama.io/notes/cs110l/2021-04-29-multiprocessing/</guid><description>C: fork() # Why it&amp;rsquo;s problematic:
Accidentally nesting forks when spawning multiple children Children can execute code they weren&amp;rsquo;t supposed to Accessing data structures during threading Zombie children if waitpid() isn&amp;rsquo;t called C: execvp() # Execute code we want to run concurrently in a separate executable, using arguments or pipes for args Simple and powerful: can make any changes to environment before executing a program, but this isn&amp;rsquo;t easy Common multiprocessing paradigm to replace fork and execvp # fork() and exec() still exist Define higher-level abstraction for common cases ex.</description></item></channel></rss>